items:
- uid: System.Threading.ReaderWriterLockSlim
  commentId: T:System.Threading.ReaderWriterLockSlim
  id: ReaderWriterLockSlim
  parent: System.Threading
  children:
  - System.Threading.ReaderWriterLockSlim.#ctor
  - System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)
  - System.Threading.ReaderWriterLockSlim.CurrentReadCount
  - System.Threading.ReaderWriterLockSlim.Dispose
  - System.Threading.ReaderWriterLockSlim.EnterReadLock
  - System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock
  - System.Threading.ReaderWriterLockSlim.EnterWriteLock
  - System.Threading.ReaderWriterLockSlim.ExitReadLock
  - System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock
  - System.Threading.ReaderWriterLockSlim.ExitWriteLock
  - System.Threading.ReaderWriterLockSlim.IsReadLockHeld
  - System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld
  - System.Threading.ReaderWriterLockSlim.IsWriteLockHeld
  - System.Threading.ReaderWriterLockSlim.RecursionPolicy
  - System.Threading.ReaderWriterLockSlim.RecursiveReadCount
  - System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount
  - System.Threading.ReaderWriterLockSlim.RecursiveWriteCount
  - System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)
  - System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)
  - System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)
  - System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)
  - System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)
  - System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)
  - System.Threading.ReaderWriterLockSlim.WaitingReadCount
  - System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount
  - System.Threading.ReaderWriterLockSlim.WaitingWriteCount
  langs:
  - csharp
  - vb
  name: ReaderWriterLockSlim
  nameWithType: ReaderWriterLockSlim
  fullName: System.Threading.ReaderWriterLockSlim
  type: Class
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReaderWriterLockSlim
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 53
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.</p>\n"
  remarks: "\n<p>Use <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> to protect a resource that is read by multiple threads and written to by one thread at a time. <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.</p>\n<p>\n<xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> is similar to <xref href=\"System.Threading.ReaderWriterLock\" data-throw-if-not-resolved=\"false\"></xref>, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref>avoids many cases of potential deadlock. In addition, the performance of <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> is significantly better than <xref href=\"System.Threading.ReaderWriterLock\" data-throw-if-not-resolved=\"false\"></xref>. <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> is recommended for all new development.</p>\n<p>By default, new instances of <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> are created with the <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> flag and do not allow recursion. This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks. To simplify migration from existing projects that use <xref href=\"System.Threading.Monitor\" data-throw-if-not-resolved=\"false\"></xref> or <xref href=\"System.Threading.ReaderWriterLock\" data-throw-if-not-resolved=\"false\"></xref>, you can use the <xref href=\"System.Threading.LockRecursionPolicy.SupportsRecursion\" data-throw-if-not-resolved=\"false\"></xref> flag to create instances of <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> that allow recursion.</p>\n<p>A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode. (In the rest of this topic, \"upgradeable read mode\" is referred to as \"upgradeable mode\", and the phrase \"enter <em>x</em> mode\" is used in preference to the longer phrase \"enter the lock in <em>x</em> mode\".)</p>\n<p>Regardless of recursion policy, only one thread can be in write mode at any time. When a thread is in write mode, no other thread can enter the lock in any mode. Only one thread can be in upgradeable mode at any time. Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode. </p>\n<p>This type implements the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref href=\"System.IDisposable.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method in a <strong>try</strong>/<strong>catch</strong> block. To dispose of it indirectly, use a language construct such as <strong>using</strong> (in C#) or <strong>Using</strong> (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <xref href=\"System.IDisposable\" data-throw-if-not-resolved=\"false\"></xref> interface topic. </p>\n<p>\n<xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> has managed thread affinity; that is, each <xref href=\"System.Threading.Thread\" data-throw-if-not-resolved=\"false\"></xref> object must make its own method calls to enter and exit lock modes. No thread can change the mode of another thread. </p>\n<p>If a <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> does not allow recursion, a thread that tries to enter the lock can block for several reasons:</p>\n<ul><li>\n<p>A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.</p>\n<p>Blocking new readers when writers are queued is a lock fairness policy that favors writers. The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios. Future versions of the .NET Framework may introduce new fairness policies. </p>\n</li><li>\n<p>A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode. </p>\n</li><li>\n<p>A thread that tries to enter write mode blocks if there is a thread in any of the three modes. </p>\n</li></ul>\n"
  syntax:
    content: 'public class ReaderWriterLockSlim : IDisposable'
    content.vb: >-
      Public Class ReaderWriterLockSlim
          Implements IDisposable
  inheritance:
  - System.Object
  implements:
  - System.IDisposable
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Threading.ReaderWriterLockSlim.#ctor
  commentId: M:System.Threading.ReaderWriterLockSlim.#ctor
  id: '#ctor'
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: ReaderWriterLockSlim()
  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim()
  fullName: System.Threading.ReaderWriterLockSlim.ReaderWriterLockSlim()
  type: Constructor
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 135
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> class with default property values.</p>\n"
  remarks: "\n<p>A <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> that is initialized with this constructor does not allow recursion. That is, the <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property returns <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n<p>For more information about recursion policy and its effects, see the <xref href=\"System.Threading.LockRecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> enumeration and the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: public ReaderWriterLockSlim()
    content.vb: Public Sub New
  seealso:
  - type: System.Threading.LockRecursionPolicy
    commentId: T:System.Threading.LockRecursionPolicy
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)
  commentId: M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)
  id: '#ctor(System.Threading.LockRecursionPolicy)'
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: ReaderWriterLockSlim(LockRecursionPolicy)
  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim(LockRecursionPolicy)
  fullName: System.Threading.ReaderWriterLockSlim.ReaderWriterLockSlim(System.Threading.LockRecursionPolicy)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 140
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> class, specifying the lock recursion policy.</p>\n"
  remarks: "\n<p>Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and a thread has entered the lock in read mode, <xref href=\"System.Threading.LockRecursionException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <xref href=\"System.Threading.LockRecursionException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the thread tries to reenter the lock in any mode. </p>\n<p>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting. </p>\n<p>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. </p>\n<p>For more information about recursion policy and its effects, see the <xref href=\"System.Threading.LockRecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> enumeration and the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: public ReaderWriterLockSlim(LockRecursionPolicy recursionPolicy)
    content.vb: Public Sub New(recursionPolicy As LockRecursionPolicy)
    parameters:
    - id: recursionPolicy
      type: System.Threading.LockRecursionPolicy
      description: "\n<p>One of the enumeration values that specifies the lock recursion policy.</p>\n"
  seealso:
  - type: System.Threading.LockRecursionPolicy
    commentId: T:System.Threading.LockRecursionPolicy
  - type: System.Threading.ReaderWriterLockSlim.RecursionPolicy
    commentId: P:System.Threading.ReaderWriterLockSlim.RecursionPolicy
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.CurrentReadCount
  commentId: P:System.Threading.ReaderWriterLockSlim.CurrentReadCount
  id: CurrentReadCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: CurrentReadCount
  nameWithType: ReaderWriterLockSlim.CurrentReadCount
  fullName: System.Threading.ReaderWriterLockSlim.CurrentReadCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CurrentReadCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1208
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the total number of unique threads that have entered the lock in read mode.</p>\n"
  remarks: "\n<p>A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.</p>\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int CurrentReadCount { get; }
    content.vb: Public ReadOnly Property CurrentReadCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The number of unique threads that have entered the lock in read mode.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.IsReadLockHeld
  commentId: P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld
  id: IsReadLockHeld
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: IsReadLockHeld
  nameWithType: ReaderWriterLockSlim.IsReadLockHeld
  fullName: System.Threading.ReaderWriterLockSlim.IsReadLockHeld
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsReadLockHeld
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1160
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets a value that indicates whether the current thread has entered the lock in read mode.</p>\n"
  remarks: "\n<p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>\n"
  syntax:
    content: public bool IsReadLockHeld { get; }
    content.vb: Public ReadOnly Property IsReadLockHeld As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread has entered read mode; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld
  commentId: P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld
  id: IsUpgradeableReadLockHeld
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: IsUpgradeableReadLockHeld
  nameWithType: ReaderWriterLockSlim.IsUpgradeableReadLockHeld
  fullName: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsUpgradeableReadLockHeld
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1171
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets a value that indicates whether the current thread has entered the lock in upgradeable mode. </p>\n"
  remarks: "\n<p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>\n"
  syntax:
    content: public bool IsUpgradeableReadLockHeld { get; }
    content.vb: Public ReadOnly Property IsUpgradeableReadLockHeld As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread has entered upgradeable mode; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld
  commentId: P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld
  id: IsWriteLockHeld
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: IsWriteLockHeld
  nameWithType: ReaderWriterLockSlim.IsWriteLockHeld
  fullName: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsWriteLockHeld
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1182
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets a value that indicates whether the current thread has entered the lock in write mode.</p>\n"
  remarks: "\n<p>This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.</p>\n"
  syntax:
    content: public bool IsWriteLockHeld { get; }
    content.vb: Public ReadOnly Property IsWriteLockHeld As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread has entered write mode; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.RecursionPolicy
  commentId: P:System.Threading.ReaderWriterLockSlim.RecursionPolicy
  id: RecursionPolicy
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: RecursionPolicy
  nameWithType: ReaderWriterLockSlim.RecursionPolicy
  fullName: System.Threading.ReaderWriterLockSlim.RecursionPolicy
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RecursionPolicy
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1193
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets a value that indicates the recursion policy for the current <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object.</p>\n"
  remarks: "\n<p>Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and a thread has entered the lock in read mode, <xref href=\"System.Threading.LockRecursionException\" data-throw-if-not-resolved=\"false\"></xref> is thrown if the thread tries to reenter the lock in read mode. </p>\n<p>A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting. </p>\n<p>Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. </p>\n<p>For more information about recursion policy and its effects, see the <xref href=\"System.Threading.LockRecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> enumeration and the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  syntax:
    content: public LockRecursionPolicy RecursionPolicy { get; }
    content.vb: Public ReadOnly Property RecursionPolicy As LockRecursionPolicy
    parameters: []
    return:
      type: System.Threading.LockRecursionPolicy
      description: "\n<p>One of the enumeration values that specifies the lock recursion policy.</p>\n"
  seealso:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.RecursiveReadCount
  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount
  id: RecursiveReadCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: RecursiveReadCount
  nameWithType: ReaderWriterLockSlim.RecursiveReadCount
  fullName: System.Threading.ReaderWriterLockSlim.RecursiveReadCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RecursiveReadCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1222
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.</p>\n"
  remarks: "\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int RecursiveReadCount { get; }
    content.vb: Public ReadOnly Property RecursiveReadCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or n if the thread has entered the lock recursively n - 1 times.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount
  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount
  id: RecursiveUpgradeCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: RecursiveUpgradeCount
  nameWithType: ReaderWriterLockSlim.RecursiveUpgradeCount
  fullName: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RecursiveUpgradeCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1235
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.</p>\n"
  remarks: "\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int RecursiveUpgradeCount { get; }
    content.vb: Public ReadOnly Property RecursiveUpgradeCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or n if the thread has entered upgradeable mode recursively n - 1 times.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount
  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount
  id: RecursiveWriteCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: RecursiveWriteCount
  nameWithType: ReaderWriterLockSlim.RecursiveWriteCount
  fullName: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RecursiveWriteCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1259
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.</p>\n"
  remarks: "\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int RecursiveWriteCount { get; }
    content.vb: Public ReadOnly Property RecursiveWriteCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or n if the thread has entered write mode recursively n - 1 times.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.WaitingReadCount
  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingReadCount
  id: WaitingReadCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: WaitingReadCount
  nameWithType: ReaderWriterLockSlim.WaitingReadCount
  fullName: System.Threading.ReaderWriterLockSlim.WaitingReadCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitingReadCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1283
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the total number of threads that are waiting to enter the lock in read mode.</p>\n"
  remarks: "\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int WaitingReadCount { get; }
    content.vb: Public ReadOnly Property WaitingReadCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The total number of threads that are waiting to enter read mode.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount
  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount
  id: WaitingUpgradeCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: WaitingUpgradeCount
  nameWithType: ReaderWriterLockSlim.WaitingUpgradeCount
  fullName: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitingUpgradeCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1291
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the total number of threads that are waiting to enter the lock in upgradeable mode.</p>\n"
  remarks: "\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int WaitingUpgradeCount { get; }
    content.vb: Public ReadOnly Property WaitingUpgradeCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The total number of threads that are waiting to enter upgradeable mode.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.WaitingWriteCount
  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount
  id: WaitingWriteCount
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: WaitingWriteCount
  nameWithType: ReaderWriterLockSlim.WaitingWriteCount
  fullName: System.Threading.ReaderWriterLockSlim.WaitingWriteCount
  type: Property
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WaitingWriteCount
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1299
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Gets the total number of threads that are waiting to enter the lock in write mode.</p>\n"
  remarks: "\n<p>Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.</p>\n"
  syntax:
    content: public int WaitingWriteCount { get; }
    content.vb: Public ReadOnly Property WaitingWriteCount As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>The total number of threads that are waiting to enter write mode.</p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
- uid: System.Threading.ReaderWriterLockSlim.Dispose
  commentId: M:System.Threading.ReaderWriterLockSlim.Dispose
  id: Dispose
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: Dispose()
  nameWithType: ReaderWriterLockSlim.Dispose()
  fullName: System.Threading.ReaderWriterLockSlim.Dispose()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Dispose
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 1117
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases all resources used by the current instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  remarks: "\n<p>Call <xref href=\"System.Threading.ReaderWriterLockSlim.Dispose\" data-throw-if-not-resolved=\"false\"></xref> when you are finished using the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref>. The <xref href=\"System.Threading.ReaderWriterLockSlim.Dispose\" data-throw-if-not-resolved=\"false\"></xref> method leaves the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> in an unusable state. After calling <xref href=\"System.Threading.ReaderWriterLockSlim.Dispose\" data-throw-if-not-resolved=\"false\"></xref>, you must release all references to the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> so the garbage collector can reclaim the memory that the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> was occupying. For more information, see Cleaning Up Unmanaged Resources and Implementing a Dispose Method.</p>\n<p>Always call <xref href=\"System.Threading.ReaderWriterLockSlim.Dispose\" data-throw-if-not-resolved=\"false\"></xref> before you release your last reference to the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object.  </p>\n"
  syntax:
    content: public void Dispose()
    content.vb: Public Sub Dispose
  exceptions:
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>\n<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingReadCount\" data-throw-if-not-resolved=\"false\"></xref> is greater than zero. </p>\n<p>-or-</p>\n<p>\n<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\" data-throw-if-not-resolved=\"false\"></xref> is greater than zero. </p>\n<p>-or-</p>\n<p>\n<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingWriteCount\" data-throw-if-not-resolved=\"false\"></xref> is greater than zero. </p>\n"
  implements:
  - System.IDisposable.Dispose
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.EnterReadLock
  commentId: M:System.Threading.ReaderWriterLockSlim.EnterReadLock
  id: EnterReadLock
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: EnterReadLock()
  nameWithType: ReaderWriterLockSlim.EnterReadLock()
  fullName: System.Threading.ReaderWriterLockSlim.EnterReadLock()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EnterReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 205
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in read mode.</p>\n"
  remarks: "\n<p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval. </p>\n<p>Multiple threads can enter read mode at the same time.</p>\n<p>If one or more threads are waiting to enter write mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.EnterReadLock\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have either timed out or entered write mode and then exited from it.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>\n<p>At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref href=\"System.Threading.ReaderWriterLockSlim.EnterReadLock\" data-throw-if-not-resolved=\"false\"></xref> method enter read mode immediately and do not block.</p>\n"
  syntax:
    content: public void EnterReadLock()
    content.vb: Public Sub EnterReadLock
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The current thread cannot acquire the write lock when it holds the read lock.</p>\n<p>-or-</p>\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the read lock. </p>\n<p>-or-</p>\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the write lock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock
  commentId: M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock
  id: EnterUpgradeableReadLock
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: EnterUpgradeableReadLock()
  nameWithType: ReaderWriterLockSlim.EnterUpgradeableReadLock()
  fullName: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EnterUpgradeableReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 588
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in upgradeable mode.</p>\n"
  remarks: "\n<p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.</p>\n<p>Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.</p>\n<p>Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>\n<p>If one or more threads are waiting to enter write mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have either timed out or entered write mode and then exited from it.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>\n"
  syntax:
    content: public void EnterUpgradeableReadLock()
    content.vb: Public Sub EnterUpgradeableReadLock
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock in any mode. </p>\n<p>-or-</p>\n<p>The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.EnterWriteLock
  commentId: M:System.Threading.ReaderWriterLockSlim.EnterWriteLock
  id: EnterWriteLock
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: EnterWriteLock()
  nameWithType: ReaderWriterLockSlim.EnterWriteLock()
  fullName: System.Threading.ReaderWriterLockSlim.EnterWriteLock()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: EnterWriteLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 405
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in write mode.</p>\n"
  remarks: "\n<p>This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.</p>\n<p>If other threads have entered the lock in read mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.EnterWriteLock\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>\n"
  syntax:
    content: public void EnterWriteLock()
    content.vb: Public Sub EnterWriteLock
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock in any mode. </p>\n<p>-or-</p>\n<p>The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.ExitReadLock
  commentId: M:System.Threading.ReaderWriterLockSlim.ExitReadLock
  id: ExitReadLock
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: ExitReadLock()
  nameWithType: ReaderWriterLockSlim.ExitReadLock()
  fullName: System.Threading.ReaderWriterLockSlim.ExitReadLock()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExitReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 725
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).</p>\n"
  remarks: "\n<p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter. </p>\n<p>Exiting the lock might signal other waiting threads.</p>\n"
  syntax:
    content: public void ExitReadLock()
    content.vb: Public Sub ExitReadLock
  exceptions:
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The current thread has not entered the lock in read mode. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock
  commentId: M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock
  id: ExitUpgradeableReadLock
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: ExitUpgradeableReadLock()
  nameWithType: ReaderWriterLockSlim.ExitUpgradeableReadLock()
  fullName: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExitUpgradeableReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 812
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).</p>\n"
  remarks: "\n<p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter. </p>\n<p>Exiting the lock might signal other waiting threads.</p>\n"
  syntax:
    content: public void ExitUpgradeableReadLock()
    content.vb: Public Sub ExitUpgradeableReadLock
  exceptions:
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The current thread has not entered the lock in upgradeable mode.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.ExitWriteLock
  commentId: M:System.Threading.ReaderWriterLockSlim.ExitWriteLock
  id: ExitWriteLock
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: ExitWriteLock()
  nameWithType: ReaderWriterLockSlim.ExitWriteLock()
  fullName: System.Threading.ReaderWriterLockSlim.ExitWriteLock()
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ExitWriteLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 765
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).</p>\n"
  remarks: "\n<p>This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter. </p>\n<p>Exiting the lock might signal other waiting threads.</p>\n"
  syntax:
    content: public void ExitWriteLock()
    content.vb: Public Sub ExitWriteLock
  exceptions:
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The current thread has not entered the lock in write mode.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)
  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)
  id: TryEnterReadLock(System.Int32)
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: TryEnterReadLock(Int32)
  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(Int32)
  fullName: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryEnterReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 271
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in read mode, with an optional integer time-out.</p>\n"
  remarks: "\n<p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>\n<p>Multiple threads can enter read mode at the same time.</p>\n<p>If one or more threads are waiting to enter write mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>\n<p>One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method enter read mode immediately and do not block.</p>\n"
  syntax:
    content: public bool TryEnterReadLock(int millisecondsTimeout)
    content.vb: Public Function TryEnterReadLock(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>) to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1), which is the only negative value allowed.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)
  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)
  id: TryEnterReadLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: TryEnterReadLock(TimeSpan)
  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryEnterReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 266
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in read mode, with an optional time-out.</p>\n"
  remarks: "\n<p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>\n<p>Multiple threads can enter the lock in read mode at the same time.</p>\n<p>If one or more threads are queued to enter write mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode. </p>\n<p>One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\" data-throw-if-not-resolved=\"false\"></xref> method enter read mode immediately and do not block.</p>\n"
  syntax:
    content: public bool TryEnterReadLock(TimeSpan timeout)
    content.vb: Public Function TryEnterReadLock(timeout As TimeSpan) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>The interval to wait, or -1 milliseconds to wait indefinitely. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the calling thread entered read mode, otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>\n<p>-or-</p>\n<p>The value of <em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> milliseconds. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)
  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)
  id: TryEnterUpgradeableReadLock(System.Int32)
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: TryEnterUpgradeableReadLock(Int32)
  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(Int32)
  fullName: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryEnterUpgradeableReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 598
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in upgradeable mode, with an optional time-out.</p>\n"
  remarks: "\n<p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>\n<p>Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode. </p>\n<p>Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>\n<p>If one or more threads are waiting to enter write mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>\n"
  syntax:
    content: public bool TryEnterUpgradeableReadLock(int millisecondsTimeout)
    content.vb: Public Function TryEnterUpgradeableReadLock(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>) to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock. </p>\n<p>-or-</p>\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1), which is the only negative value allowed. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)
  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)
  id: TryEnterUpgradeableReadLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: TryEnterUpgradeableReadLock(TimeSpan)
  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryEnterUpgradeableReadLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 593
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in upgradeable mode, with an optional time-out.</p>\n"
  remarks: "\n<p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>\n<p>Use upgradeable mode when a thread usually accesses the resource protected by the <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode. </p>\n<p>Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.</p>\n<p>If one or more threads are waiting to enter write mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode. </p>\n"
  syntax:
    content: public bool TryEnterUpgradeableReadLock(TimeSpan timeout)
    content.vb: Public Function TryEnterUpgradeableReadLock(timeout As TimeSpan) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the calling thread entered upgradeable mode, otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock. </p>\n<p>-or-</p>\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>\n<p>-or-</p>\n<p>The value of <em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> milliseconds. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)
  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)
  id: TryEnterWriteLock(System.Int32)
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: TryEnterWriteLock(Int32)
  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(Int32)
  fullName: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryEnterWriteLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 415
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in write mode, with an optional time-out.</p>\n"
  remarks: "\n<p>If <em>millisecondsTimeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>\n<p>If other threads have entered the lock in read mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>\n"
  syntax:
    content: public bool TryEnterWriteLock(int millisecondsTimeout)
    content.vb: Public Function TryEnterWriteLock(millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>) to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock. </p>\n<p>-or-</p>\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>millisecondsTimeout</em> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (-1), which is the only negative value allowed. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)
  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)
  id: TryEnterWriteLock(System.TimeSpan)
  parent: System.Threading.ReaderWriterLockSlim
  langs:
  - csharp
  - vb
  name: TryEnterWriteLock(TimeSpan)
  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(TimeSpan)
  fullName: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryEnterWriteLock
    path: src/System.Threading/src/System/Threading/ReaderWriterLockSlim.cs
    startLine: 410
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Tries to enter the lock in write mode, with an optional time-out.</p>\n"
  remarks: "\n<p>If <em>timeout</em> is 0 (zero), this method checks the lock state and returns <strong>false</strong> immediately if the desired state is unavailable.</p>\n<p>If other threads have entered the lock in read mode, a thread that calls the <xref href=\"System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.</p>\n<p>If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode. </p>\n"
  syntax:
    content: public bool TryEnterWriteLock(TimeSpan timeout)
    content.vb: Public Function TryEnterWriteLock(timeout As TimeSpan) As Boolean
    parameters:
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>The interval to wait, or -1 milliseconds to wait indefinitely.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the calling thread entered write mode, otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.Threading.LockRecursionException
    commentId: T:System.Threading.LockRecursionException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\" data-throw-if-not-resolved=\"false\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\" data-throw-if-not-resolved=\"false\"></xref> and the current thread has already entered the lock. </p>\n<p>-or-</p>\n<p>The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock. </p>\n<p>-or-</p>\n<p>The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>timeout</em> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.</p>\n<p>-or-</p>\n<p>The value of <em>timeout</em> is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref> milliseconds. </p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>The <xref href=\"System.Threading.ReaderWriterLockSlim\" data-throw-if-not-resolved=\"false\"></xref> object has been disposed. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  nameWithType: System.Threading
  fullName: System.Threading
  commentId: N:System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  nameWithType: Object
  fullName: System.Object
  commentId: T:System.Object
- uid: System.IDisposable
  parent: System
  isExternal: false
  name: IDisposable
  nameWithType: IDisposable
  fullName: System.IDisposable
  commentId: T:System.IDisposable
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  nameWithType: Object.ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    nameWithType: Object.ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.ToString
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  nameWithType: Object.Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.Equals(System.Object)
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  nameWithType: Object.Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    nameWithType: Object.Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.Equals(System.Object,System.Object)
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  nameWithType: Object.ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    nameWithType: Object.ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    nameWithType: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    nameWithType: Object
    fullName: System.Object
    isExternal: true
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  nameWithType: Object.GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    nameWithType: Object.GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.GetHashCode
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  nameWithType: Object.GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    nameWithType: Object.GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.GetType
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  nameWithType: Object.MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    nameWithType: Object.MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.Object.MemberwiseClone
- uid: System
  isExternal: false
  name: System
  nameWithType: System
  fullName: System
  commentId: N:System
- uid: System.Threading.LockRecursionPolicy
  parent: System.Threading
  isExternal: false
  name: LockRecursionPolicy
  nameWithType: LockRecursionPolicy
  fullName: System.Threading.LockRecursionPolicy
  commentId: T:System.Threading.LockRecursionPolicy
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  nameWithType: Int32
  fullName: System.Int32
  commentId: T:System.Int32
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  nameWithType: Boolean
  fullName: System.Boolean
  commentId: T:System.Boolean
- uid: System.IDisposable.Dispose
  parent: System.IDisposable
  isExternal: false
  name: Dispose()
  nameWithType: IDisposable.Dispose()
  fullName: System.IDisposable.Dispose()
  spec.csharp:
  - uid: System.IDisposable.Dispose
    name: Dispose
    nameWithType: IDisposable.Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  spec.vb:
  - uid: System.IDisposable.Dispose
    name: Dispose
    nameWithType: IDisposable.Dispose
    fullName: System.IDisposable.Dispose
  - name: (
    nameWithType: (
    fullName: (
  - name: )
    nameWithType: )
    fullName: )
  commentId: M:System.IDisposable.Dispose
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  nameWithType: TimeSpan
  fullName: System.TimeSpan
  commentId: T:System.TimeSpan
- uid: System.Threading.SynchronizationLockException
  isExternal: false
  name: SynchronizationLockException
  nameWithType: SynchronizationLockException
  fullName: System.Threading.SynchronizationLockException
  commentId: T:System.Threading.SynchronizationLockException
- uid: System.Threading.LockRecursionException
  isExternal: false
  name: LockRecursionException
  nameWithType: LockRecursionException
  fullName: System.Threading.LockRecursionException
  commentId: T:System.Threading.LockRecursionException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  nameWithType: ObjectDisposedException
  fullName: System.ObjectDisposedException
  commentId: T:System.ObjectDisposedException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  nameWithType: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
  commentId: T:System.ArgumentOutOfRangeException
