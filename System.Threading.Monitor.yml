items:
- uid: System.Threading.Monitor
  commentId: T:System.Threading.Monitor
  id: Monitor
  parent: System.Threading
  children:
  - System.Threading.Monitor.Enter(System.Object)
  - System.Threading.Monitor.Enter(System.Object,System.Boolean@)
  - System.Threading.Monitor.Exit(System.Object)
  - System.Threading.Monitor.IsEntered(System.Object)
  - System.Threading.Monitor.Pulse(System.Object)
  - System.Threading.Monitor.PulseAll(System.Object)
  - System.Threading.Monitor.TryEnter(System.Object)
  - System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)
  - System.Threading.Monitor.TryEnter(System.Object,System.Int32)
  - System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)
  - System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)
  - System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)
  - System.Threading.Monitor.Wait(System.Object)
  - System.Threading.Monitor.Wait(System.Object,System.Int32)
  - System.Threading.Monitor.Wait(System.Object,System.TimeSpan)
  langs:
  - csharp
  - vb
  name: Monitor
  fullName: System.Threading.Monitor
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Monitor
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 28
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Provides a mechanism that synchronizes access to objects.</p>\n"
  example:
  - <p>The following example uses the <xref href="System.Threading.Monitor" data-throw-if-not-resolved="false"></xref> class to synchronize access to a single instance of a random number generator represented by the <xref href="System.Random" data-throw-if-not-resolved="false"></xref> class. The example creates ten tasks, each of which executes asynchronously on a thread pool thread. Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum. After all tasks have executed, these two values are then used to calculate the overall mean. </p>System.Threading.Monitor.Class#1<p>Because they can be accessed from any task running on a thread pool thread, access to the variables <code>total</code> and <code>n</code> must also be synchronized. The <xref href="System.Threading.Interlocked.Add(System.Int64@,System.Int64)" data-throw-if-not-resolved="false"></xref> method is used for this purpose. </p>
  - '<p>The following example demonstrates the combined use of the <xref href="System.Threading.Monitor" data-throw-if-not-resolved="false"></xref> class (implemented with the <strong>lock</strong> or <strong>SyncLock</strong> language construct), the <xref href="System.Threading.Interlocked" data-throw-if-not-resolved="false"></xref> class, and the <xref href="System.Threading.AutoResetEvent" data-throw-if-not-resolved="false"></xref> class. It defines two <strong>internal</strong> (in C#) or <strong>Friend</strong> (in Visual Basic) classes, <code>SyncResource</code> and <code>UnSyncResource</code>, that respectively provide synchronized and unsynchronized access to a resource. To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref href="System.Threading.Thread.ManagedThreadId" data-throw-if-not-resolved="false"></xref> property is even, the method calls <xref href="System.Threading.Thread.Sleep(System.Int32)" data-throw-if-not-resolved="false"></xref> to introduce a delay of 2,000 milliseconds. Note that, because the <code>SyncResource</code> class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock. This prevents malicious code from taking a lock on a public object. </p>Conceptual.Monitors#1<p>The example defines a variable, <code>numOps</code>, that defines the number of threads that will attempt to access the resource. The application thread calls the <xref href="System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" data-throw-if-not-resolved="false"></xref> method for synchronized and unsynchronized access five times each. The <xref href="System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" data-throw-if-not-resolved="false"></xref> method has a single parameter, a delegate that accepts no parameters and returns no value. For synchronized access, it invokes the <code>SyncUpdateResource</code> method; for unsynchronized access, it invokes the <code>UnSyncUpdateResource</code> method. After each set of method calls, the application thread calls the <see href="https://msdn.microsoft.com/library/58195swd.aspx">AutoResetEvent.WaitOne</see> method so that it blocks until the <xref href="System.Threading.AutoResetEvent" data-throw-if-not-resolved="false"></xref> instance is signaled. </p><p>Each call to the <code>SyncUpdateResource</code> method calls the internal <code>SyncResource.Access</code> method and then calls the <xref href="System.Threading.Interlocked.Decrement(System.Int64@)" data-throw-if-not-resolved="false"></xref> method to decrement the <code>numOps</code> counter. The <xref href="System.Threading.Interlocked.Decrement(System.Int64@)" data-throw-if-not-resolved="false"></xref> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread''s decremented value has been stored in the variable. When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the <code>SyncUpdateResource</code> method calls the <see href="https://msdn.microsoft.com/library/system.threading.eventwaithandle.set.aspx">EventWaitHandle.Set</see> method, which signals the main thread to continue execution. </p><p>Each call to the <code>UnSyncUpdateResource</code> method calls the internal <code>UnSyncResource.Access</code> method and then calls the <xref href="System.Threading.Interlocked.Decrement(System.Int64@)" data-throw-if-not-resolved="false"></xref> method to decrement the <code>numOps</code> counter. Once again, the <xref href="System.Threading.Interlocked.Decrement(System.Int64@)" data-throw-if-not-resolved="false"></xref> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread''s decremented value has been assigned to the variable. When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the <code>UnSyncUpdateResource</code> method calls the <see href="https://msdn.microsoft.com/library/system.threading.eventwaithandle.set.aspx">EventWaitHandle.Set</see> method, which signals the main thread to continue execution.</p><p>As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor. On the other hand, without the lock, the <code>UnSyncResource.Access</code> method is called in the order in which threads reach it. </p>'
  syntax:
    content: >-
      [HostProtection(Synchronization = true, ExternalThreading = true)]

      [ComVisible(true)]

      public class Monitor
    content.vb: >-
      <HostProtection(Synchronization:=True, ExternalThreading:=True)>

      <ComVisible(True)>

      Public Class Monitor
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.ToString
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
  nameWithType: Monitor
- uid: System.Threading.Monitor.Enter(System.Object)
  commentId: M:System.Threading.Monitor.Enter(System.Object)
  id: Enter(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Enter(Object)
  fullName: System.Threading.Monitor.Enter(System.Object)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Acquires an exclusive lock on the specified object.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to use the <strong>Enter</strong> method.</p>MonitorExmpl2#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [MethodImpl(MethodImplOptions.InternalCall)]

      public static void Enter(object obj)
    content.vb: >-
      <SecuritySafeCritical>

      <MethodImpl(MethodImplOptions.InternalCall)>

      Public Shared Sub Enter(obj As Object)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the monitor lock. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.Enter(Object)
- uid: System.Threading.Monitor.Enter(System.Object,System.Boolean@)
  commentId: M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)
  id: Enter(System.Object,System.Boolean@)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Enter(Object, ref Boolean)
  fullName: System.Threading.Monitor.Enter(System.Object, ref System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Enter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 50
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</p>\n"
  example:
  - "\n<p>The following code shows the basic pattern for using the <xref href=\"System.Threading.Monitor.Enter(System.Object,System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> method overload. This overload always sets the value of the variable that is passed to the <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) <em>lockTaken</em>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</p>System.Threading.Monitor.Enter#2"
  syntax:
    content: public static void Enter(object obj, ref bool lockTaken)
    content.vb: Public Shared Sub Enter(obj As Object, ByRef lockTaken As Boolean)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to wait. </p>\n"
    - id: lockTaken
      type: System.Boolean
      description: "\n<p>The result of the attempt to acquire the lock, passed by reference. The input must be <strong>false</strong>. The output is <strong>true</strong> if the lock is acquired; otherwise, the output is <strong>false</strong>. The output is set even if an exception occurs during the attempt to acquire the lock. </p>\n<p>Note   If no exception occurs, the output of this method is always <strong>true</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The input to <em>lockTaken</em> is <strong>true</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Monitor.Enter(System.Object, ByRef System.Boolean)
  name.vb: Enter(Object, ByRef Boolean)
  nameWithType: Monitor.Enter(Object, ref Boolean)
  nameWithType.vb: Monitor.Enter(Object, ByRef Boolean)
- uid: System.Threading.Monitor.Exit(System.Object)
  commentId: M:System.Threading.Monitor.Exit(System.Object)
  id: Exit(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Exit(Object)
  fullName: System.Threading.Monitor.Exit(System.Object)
  type: Method
  source:
    path: System.Private.CoreLib
    isExternal: true
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases an exclusive lock on the specified object.</p>\n"
  example:
  - "\n<p>The following example demonstrates how to use the <strong>Exit</strong> method.</p>MonitorExmpl2#1"
  syntax:
    content: >-
      [SecuritySafeCritical]

      [MethodImpl(MethodImplOptions.InternalCall)]

      [ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)]

      public static void Exit(object obj)
    content.vb: >-
      <SecuritySafeCritical>

      <MethodImpl(MethodImplOptions.InternalCall)>

      <ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)>

      Public Shared Sub Exit(obj As Object)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to release the lock. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The current thread does not own the lock for the specified object. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.Exit(Object)
- uid: System.Threading.Monitor.IsEntered(System.Object)
  commentId: M:System.Threading.Monitor.IsEntered(System.Object)
  id: IsEntered(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: IsEntered(Object)
  fullName: System.Threading.Monitor.IsEntered(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsEntered
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 160
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Determines whether the current thread holds the lock on the specified object. </p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public static bool IsEntered(object obj)
    content.vb: >-
      <SecuritySafeCritical>

      Public Shared Function IsEntered(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object to test. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread holds the lock on <em>obj</em>; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>obj</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.IsEntered(Object)
- uid: System.Threading.Monitor.Pulse(System.Object)
  commentId: M:System.Threading.Monitor.Pulse(System.Object)
  id: Pulse(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Pulse(Object)
  fullName: System.Threading.Monitor.Pulse(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Pulse
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 225
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Notifies a thread in the waiting queue of a change in the locked object's state.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public static void Pulse(object obj)
    content.vb: >-
      <SecuritySafeCritical>

      Public Shared Sub Pulse(obj As Object)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object a thread is waiting for. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The calling thread does not own the lock for the specified object. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.Pulse(Object)
- uid: System.Threading.Monitor.PulseAll(System.Object)
  commentId: M:System.Threading.Monitor.PulseAll(System.Object)
  id: PulseAll(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: PulseAll(Object)
  fullName: System.Threading.Monitor.PulseAll(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: PulseAll
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 243
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Notifies all waiting threads of a change in the object's state.</p>\n"
  syntax:
    content: >-
      [SecuritySafeCritical]

      public static void PulseAll(object obj)
    content.vb: >-
      <SecuritySafeCritical>

      Public Shared Sub PulseAll(obj As Object)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object that sends the pulse. </p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The calling thread does not own the lock for the specified object. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.PulseAll(Object)
- uid: System.Threading.Monitor.TryEnter(System.Object)
  commentId: M:System.Threading.Monitor.TryEnter(System.Object)
  id: TryEnter(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: TryEnter(Object)
  fullName: System.Threading.Monitor.TryEnter(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryEnter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 91
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Attempts to acquire an exclusive lock on the specified object.</p>\n"
  example:
  - "\n<p>The following code example demonstrates how to use the <strong>TryEnter</strong> method.</p>MonitorExmpl2#1"
  syntax:
    content: public static bool TryEnter(object obj)
    content.vb: Public Shared Function TryEnter(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the lock. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread acquires the lock; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.TryEnter(Object)
- uid: System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)
  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)
  id: TryEnter(System.Object,System.Boolean@)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: TryEnter(Object, ref Boolean)
  fullName: System.Threading.Monitor.TryEnter(System.Object, ref System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryEnter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 100
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</p>\n"
  example:
  - "\n<p>The following code shows the basic pattern for using the <xref href=\"System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> method overload. This overload always sets the value of the variable that is passed to the <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) <em>lockTaken</em>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</p>System.Threading.Monitor.Enter#3"
  syntax:
    content: public static void TryEnter(object obj, ref bool lockTaken)
    content.vb: Public Shared Sub TryEnter(obj As Object, ByRef lockTaken As Boolean)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the lock. </p>\n"
    - id: lockTaken
      type: System.Boolean
      description: "\n<p>The result of the attempt to acquire the lock, passed by reference. The input must be <strong>false</strong>. The output is <strong>true</strong> if the lock is acquired; otherwise, the output is <strong>false</strong>. The output is set even if an exception occurs during the attempt to acquire the lock.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The input to <em>lockTaken</em> is <strong>true</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Monitor.TryEnter(System.Object, ByRef System.Boolean)
  name.vb: TryEnter(Object, ByRef Boolean)
  nameWithType: Monitor.TryEnter(Object, ref Boolean)
  nameWithType.vb: Monitor.TryEnter(Object, ByRef Boolean)
- uid: System.Threading.Monitor.TryEnter(System.Object,System.Int32)
  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)
  id: TryEnter(System.Object,System.Int32)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: TryEnter(Object, Int32)
  fullName: System.Threading.Monitor.TryEnter(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryEnter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 118
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</p>\n"
  syntax:
    content: public static bool TryEnter(object obj, int millisecondsTimeout)
    content.vb: Public Shared Function TryEnter(obj As Object, millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the lock. </p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait for the lock. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread acquires the lock; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.TryEnter(Object, Int32)
- uid: System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)
  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)
  id: TryEnter(System.Object,System.Int32,System.Boolean@)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: TryEnter(Object, Int32, ref Boolean)
  fullName: System.Threading.Monitor.TryEnter(System.Object, System.Int32, ref System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryEnter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 140
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</p>\n"
  example:
  - "\n<p>The following code shows the basic pattern for using the <xref href=\"System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> method overload. This overload always sets the value of the variable that is passed to the <strong>ref</strong> parameter (<strong>ByRef</strong> in Visual Basic) <em>lockTaken</em>, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</p>System.Threading.Monitor.Enter#4"
  syntax:
    content: public static void TryEnter(object obj, int millisecondsTimeout, ref bool lockTaken)
    content.vb: Public Shared Sub TryEnter(obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the lock. </p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait for the lock. </p>\n"
    - id: lockTaken
      type: System.Boolean
      description: "\n<p>The result of the attempt to acquire the lock, passed by reference. The input must be <strong>false</strong>. The output is <strong>true</strong> if the lock is acquired; otherwise, the output is <strong>false</strong>. The output is set even if an exception occurs during the attempt to acquire the lock.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The input to <em>lockTaken</em> is <strong>true</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>millisecondsTimeout</em> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Monitor.TryEnter(System.Object, System.Int32, ByRef System.Boolean)
  name.vb: TryEnter(Object, Int32, ByRef Boolean)
  nameWithType: Monitor.TryEnter(Object, Int32, ref Boolean)
  nameWithType.vb: Monitor.TryEnter(Object, Int32, ByRef Boolean)
- uid: System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)
  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)
  id: TryEnter(System.Object,System.TimeSpan)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: TryEnter(Object, TimeSpan)
  fullName: System.Threading.Monitor.TryEnter(System.Object, System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryEnter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 133
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</p>\n"
  syntax:
    content: public static bool TryEnter(object obj, TimeSpan timeout)
    content.vb: Public Shared Function TryEnter(obj As Object, timeout As TimeSpan) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the lock. </p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> representing the amount of time to wait for the lock. A value of –1 millisecond specifies an infinite wait.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the current thread acquires the lock; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>timeout</em> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (–1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.TryEnter(Object, TimeSpan)
- uid: System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)
  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)
  id: TryEnter(System.Object,System.TimeSpan,System.Boolean@)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: TryEnter(Object, TimeSpan, ref Boolean)
  fullName: System.Threading.Monitor.TryEnter(System.Object, System.TimeSpan, ref System.Boolean)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: TryEnter
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 148
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</p>\n"
  example:
  - 
  syntax:
    content: public static void TryEnter(object obj, TimeSpan timeout, ref bool lockTaken)
    content.vb: Public Shared Sub TryEnter(obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to acquire the lock. </p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>The amount of time to wait for the lock. A value of –1 millisecond specifies an infinite wait.</p>\n"
    - id: lockTaken
      type: System.Boolean
      description: "\n<p>The result of the attempt to acquire the lock, passed by reference. The input must be <strong>false</strong>. The output is <strong>true</strong> if the lock is acquired; otherwise, the output is <strong>false</strong>. The output is set even if an exception occurs during the attempt to acquire the lock.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The input to <em>lockTaken</em> is <strong>true</strong>.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of <em>timeout</em> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (–1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Monitor.TryEnter(System.Object, System.TimeSpan, ByRef System.Boolean)
  name.vb: TryEnter(Object, TimeSpan, ByRef Boolean)
  nameWithType: Monitor.TryEnter(Object, TimeSpan, ref Boolean)
  nameWithType.vb: Monitor.TryEnter(Object, TimeSpan, ByRef Boolean)
- uid: System.Threading.Monitor.Wait(System.Object)
  commentId: M:System.Threading.Monitor.Wait(System.Object)
  id: Wait(System.Object)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Wait(Object)
  fullName: System.Threading.Monitor.Wait(System.Object)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 211
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases the lock on an object and blocks the current thread until it reacquires the lock.</p>\n"
  syntax:
    content: public static bool Wait(object obj)
    content.vb: Public Shared Function Wait(obj As Object) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to wait. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The calling thread does not own the lock for the specified object. </p>\n"
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "\n<p>The thread that invokes <strong>Wait</strong> is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.Wait(Object)
- uid: System.Threading.Monitor.Wait(System.Object,System.Int32)
  commentId: M:System.Threading.Monitor.Wait(System.Object,System.Int32)
  id: Wait(System.Object,System.Int32)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Wait(Object, Int32)
  fullName: System.Threading.Monitor.Wait(System.Object, System.Int32)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 201
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.</p>\n"
  syntax:
    content: public static bool Wait(object obj, int millisecondsTimeout)
    content.vb: Public Shared Function Wait(obj As Object, millisecondsTimeout As Integer) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to wait. </p>\n"
    - id: millisecondsTimeout
      type: System.Int32
      description: "\n<p>The number of milliseconds to wait before the thread enters the ready queue. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the lock was reacquired before the specified time elapsed; <strong>false</strong> if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The calling thread does not own the lock for the specified object. </p>\n"
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "\n<p>The thread that invokes <strong>Wait</strong> is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of the <em>millisecondsTimeout</em> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.Wait(Object, Int32)
- uid: System.Threading.Monitor.Wait(System.Object,System.TimeSpan)
  commentId: M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)
  id: Wait(System.Object,System.TimeSpan)
  parent: System.Threading.Monitor
  langs:
  - csharp
  - vb
  name: Wait(Object, TimeSpan)
  fullName: System.Threading.Monitor.Wait(System.Object, System.TimeSpan)
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Threading/Monitor.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Wait
    path: src/mscorlib/src/System/Threading/Monitor.cs
    startLine: 206
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.</p>\n"
  syntax:
    content: public static bool Wait(object obj, TimeSpan timeout)
    content.vb: Public Shared Function Wait(obj As Object, timeout As TimeSpan) As Boolean
    parameters:
    - id: obj
      type: System.Object
      description: "\n<p>The object on which to wait. </p>\n"
    - id: timeout
      type: System.TimeSpan
      description: "\n<p>A <xref href=\"System.TimeSpan\" data-throw-if-not-resolved=\"false\"></xref> representing the amount of time to wait before the thread enters the ready queue. </p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the lock was reacquired before the specified time elapsed; <strong>false</strong> if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>The <em>obj</em> parameter is <strong>null</strong>. </p>\n"
  - type: System.Threading.SynchronizationLockException
    commentId: T:System.Threading.SynchronizationLockException
    description: "\n<p>The calling thread does not own the lock for the specified object. </p>\n"
  - type: System.Threading.ThreadInterruptedException
    commentId: T:System.Threading.ThreadInterruptedException
    description: "\n<p>The thread that invokes <strong>Wait</strong> is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>The value of the <em>timeout</em> parameter in milliseconds is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> (–1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\" data-throw-if-not-resolved=\"false\"></xref>. </p>\n"
  seealso:
  - type: System.Threading.Thread
    commentId: T:System.Threading.Thread
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  nameWithType: Monitor.Wait(Object, TimeSpan)
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
  nameWithType: System.Threading
  commentId: N:System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
  nameWithType: Object
  commentId: T:System.Object
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.ToString()
  commentId: M:System.Object.ToString
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  nameWithType: Object.Equals(Object)
  commentId: M:System.Object.Equals(System.Object)
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  nameWithType: Object.Equals(Object, Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  nameWithType: Object.ReferenceEquals(Object, Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.GetHashCode()
  commentId: M:System.Object.GetHashCode
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.GetType()
  commentId: M:System.Object.GetType
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.MemberwiseClone()
  commentId: M:System.Object.MemberwiseClone
- uid: System
  isExternal: false
  name: System
  fullName: System
  nameWithType: System
  commentId: N:System
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
  nameWithType: Boolean
  commentId: T:System.Boolean
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
  nameWithType: Int32
  commentId: T:System.Int32
- uid: System.TimeSpan
  parent: System
  isExternal: false
  name: TimeSpan
  fullName: System.TimeSpan
  nameWithType: TimeSpan
  commentId: T:System.TimeSpan
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
  nameWithType: ArgumentNullException
  commentId: T:System.ArgumentNullException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
  nameWithType: ArgumentException
  commentId: T:System.ArgumentException
- uid: System.Threading.SynchronizationLockException
  isExternal: false
  name: SynchronizationLockException
  fullName: System.Threading.SynchronizationLockException
  nameWithType: SynchronizationLockException
  commentId: T:System.Threading.SynchronizationLockException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
  nameWithType: ArgumentOutOfRangeException
  commentId: T:System.ArgumentOutOfRangeException
- uid: System.Threading.ThreadInterruptedException
