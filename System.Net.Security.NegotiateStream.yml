items:
- uid: System.Net.Security.NegotiateStream
  commentId: T:System.Net.Security.NegotiateStream
  id: NegotiateStream
  parent: System.Net.Security
  children:
  - System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  - System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.String)
  - System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  - System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  - System.Net.Security.NegotiateStream.CanRead
  - System.Net.Security.NegotiateStream.CanSeek
  - System.Net.Security.NegotiateStream.CanTimeout
  - System.Net.Security.NegotiateStream.CanWrite
  - System.Net.Security.NegotiateStream.Flush
  - System.Net.Security.NegotiateStream.ImpersonationLevel
  - System.Net.Security.NegotiateStream.IsAuthenticated
  - System.Net.Security.NegotiateStream.IsEncrypted
  - System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  - System.Net.Security.NegotiateStream.IsServer
  - System.Net.Security.NegotiateStream.IsSigned
  - System.Net.Security.NegotiateStream.Length
  - System.Net.Security.NegotiateStream.Position
  - System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.NegotiateStream.ReadTimeout
  - System.Net.Security.NegotiateStream.RemoteIdentity
  - System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  - System.Net.Security.NegotiateStream.SetLength(System.Int64)
  - System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  - System.Net.Security.NegotiateStream.WriteTimeout
  langs:
  - csharp
  - vb
  name: NegotiateStream
  fullName: System.Net.Security.NegotiateStream
  type: Class
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/InternalNegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: NegotiateStream
    path: src/System.Net.Security/src/System/Net/SecureProtocols/InternalNegotiateStream.cs
    startLine: 14
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Provides a stream that uses the Negotiate security protocol to authenticate the client, and optionally the server, in client-server communication.</p>\n"
  remarks: "\n<p>Use the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class for authentication and to help secure information transmitted between a client and a server. Using <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>, you can do the following.</p>\n<ul><li>\n<p>Send the client's credentials to the server for Impersonation or Delegation. </p>\n</li><li>\n<p>Request server authentication.</p>\n</li><li>\n<p>Encrypt and/or sign data before transmitting it. </p>\n</li></ul>\n<p>Authentication must be performed before transmitting information. Clients request authentication using the synchronous <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient\"></see> methods, which block until the authentication completes, or the asynchronous <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient\"></see> methods, which do not block while waiting for the authentication to complete. Servers request authentication using the synchronous <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer\"></see> or asynchronous <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer\"></see> methods. The client, and optionally the server, is authenticated using the Negotiate security protocol. On Windows 95/98 systems, Windows NT LAN Manager (NTLM) is the protocol used for authentication. On other platforms the Kerberos protocol is used for authentication if both client and server support it; otherwise NTLM is used. For detailed descriptions of these protocols, see the Platform SDK documentation on MSDN, at msdn.microsoft.com/library/. The <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class performs the authentication using the Security Support Provider Interface (SSPI). </p>\n<p>When authentication succeeds, you must check the <xref href=\"System.Net.Security.NegotiateStream.IsEncrypted\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Security.NegotiateStream.IsSigned\" data-throw-if-not-resolved=\"false\"></xref> properties to determine what security services will be used by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> to help secure your data during transmission. Check the <xref href=\"System.Net.Security.NegotiateStream.IsMutuallyAuthenticated\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether mutual authentication occurred. You can get information about the remote client or server using the <xref href=\"System.Net.Security.NegotiateStream.RemoteIdentity\" data-throw-if-not-resolved=\"false\"></xref> property.</p>\n<p>If the authentication fails, you will receive an <xref href=\"System.Security.Authentication.AuthenticationException\" data-throw-if-not-resolved=\"false\"></xref> or a <xref href=\"System.Security.Authentication.InvalidCredentialException\" data-throw-if-not-resolved=\"false\"></xref>. In this case, you can retry the authentication with a different credential.</p>\n<p>You send data using the synchronous <xref href=\"System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> or asynchronous <xref href=\"System.Net.Security.NegotiateStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods. You receive data using the synchronous <xref href=\"System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> or asynchronous <xref href=\"System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> methods. If security services such as encryption or signing are enabled, these are automatically applied to your data by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>The <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> transmits data using a stream that you supply when creating the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>. When you supply this underlying stream, you have the option to specify whether closing the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> also closes the underlying stream.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the client side of a client-server connection that uses the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>. The client authenticates and sends a message to the server asynchronously.</p>NclNegoAsyncClient#0<p>The following code example demonstrates the server side of a client-server connection that uses the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> to authenticate the client and read a message sent by the client. </p>NclNegoAsyncServer#0"
  syntax:
    content: 'public class NegotiateStream : AuthenticatedStream'
    content.vb: >-
      Public Class NegotiateStream
          Inherits AuthenticatedStream
  inheritance:
  - System.Object
  - System.Net.Security.AuthenticatedStream
  inheritedMembers:
  - System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen
  - System.Net.Security.AuthenticatedStream.InnerStream
  - System.Net.Security.AuthenticatedStream.Dispose(System.Boolean)
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  commentId: M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream)
  id: '#ctor(System.IO.Stream)'
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: NegotiateStream(IO.Stream)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(System.IO.Stream)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 31
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class using the specified <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates calling this constructor.</p>NclNegoSyncClient#3"
  syntax:
    content: public NegotiateStream(IO.Stream innerStream)
    content.vb: Public Sub New(innerStream As IO.Stream)
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "\n<p>A <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> object used by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> for sending and receiving data.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  commentId: M:System.Net.Security.NegotiateStream.#ctor(System.IO.Stream,System.Boolean)
  id: '#ctor(System.IO.Stream,System.Boolean)'
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: NegotiateStream(IO.Stream, Boolean)
  fullName: System.Net.Security.NegotiateStream.NegotiateStream(System.IO.Stream, System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 32
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class using the specified <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> and stream closure behavior.</p>\n"
  remarks: "\n<p>When you specify <strong>true</strong> for the <em>leaveStreamOpen</em> parameter, closing the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> has no effect on the <em>innerStream</em> stream; you must explicitly close <em>innerStream</em> when you no longer need it.</p>\n"
  example:
  - "\n<p>The following code example demonstrates calling this constructor. This code example is part of a larger example provided for the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class.</p>NclNegoAsyncClient#1"
  syntax:
    content: public NegotiateStream(IO.Stream innerStream, bool leaveInnerStreamOpen)
    content.vb: Public Sub New(innerStream As IO.Stream, leaveInnerStreamOpen As Boolean)
    parameters:
    - id: innerStream
      type: System.IO.Stream
      description: "\n<p>A <xref href=\"System.IO.Stream\" data-throw-if-not-resolved=\"false\"></xref> object used by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> for sending and receiving data.</p>\n"
    - id: leaveInnerStreamOpen
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to indicate that closing this <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> has no effect on <em>innerstream</em>; <strong>false</strong> to indicate that closing this <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> also closes <em>innerStream</em>. See the Remarks section for more information.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>innerStream</em> is <strong>null</strong>.</p>\n<p>- or -</p>\n<p>\n<em>innerStream</em> is equal to <xref href=\"System.IO.Stream.Null\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Net.Security.NegotiateStream.CanRead
  commentId: P:System.Net.Security.NegotiateStream.CanRead
  id: CanRead
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: CanRead
  fullName: System.Net.Security.NegotiateStream.CanRead
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CanRead
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 351
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether the underlying stream is readable.</p>\n"
  remarks: "\n<p>If successful authentication has occurred, this property returns the value returned by invoking the <xref href=\"System.IO.Stream.CanRead\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. The underlying stream is specified when you create an instance of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override bool CanRead { get; }
    content.vb: Public Overrides ReadOnly Property CanRead As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if authentication has occurred and the underlying stream is readable; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.CanSeek
  commentId: P:System.Net.Security.NegotiateStream.CanSeek
  id: CanSeek
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: CanSeek
  fullName: System.Net.Security.NegotiateStream.CanSeek
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CanSeek
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 343
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether the underlying stream is seekable.</p>\n"
  remarks: "\n<p>You should not attempt to set the position of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> object or its underlying stream. The underlying stream is specified when you create an instance of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override bool CanSeek { get; }
    content.vb: Public Overrides ReadOnly Property CanSeek As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>This property always returns <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Net.Security.NegotiateStream.Position
    commentId: P:System.Net.Security.NegotiateStream.Position
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.CanTimeout
  commentId: P:System.Net.Security.NegotiateStream.CanTimeout
  id: CanTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: CanTimeout
  fullName: System.Net.Security.NegotiateStream.CanTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CanTimeout
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 359
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether the underlying stream supports time-outs.</p>\n"
  remarks: "\n<p>This property returns the value returned by invoking the <xref href=\"System.IO.Stream.CanTimeout\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. The underlying stream is specified when you create an instance of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override bool CanTimeout { get; }
    content.vb: Public Overrides ReadOnly Property CanTimeout As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the underlying stream supports time-outs; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.CanWrite
  commentId: P:System.Net.Security.NegotiateStream.CanWrite
  id: CanWrite
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: CanWrite
  fullName: System.Net.Security.NegotiateStream.CanWrite
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: CanWrite
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 367
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether the underlying stream is writable.</p>\n"
  remarks: "\n<p>If successful authentication has occurred, this property returns the value returned by invoking the <xref href=\"System.IO.Stream.CanWrite\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. The underlying stream is specified when you create an instance of the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override bool CanWrite { get; }
    content.vb: Public Overrides ReadOnly Property CanWrite As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if authentication has occurred and the underlying stream is writable; otherwise, <strong>false</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.ImpersonationLevel
  commentId: P:System.Net.Security.NegotiateStream.ImpersonationLevel
  id: ImpersonationLevel
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: ImpersonationLevel
  fullName: System.Net.Security.NegotiateStream.ImpersonationLevel
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ImpersonationLevel
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 304
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a value that indicates how the server can use the client's credentials.</p>\n"
  remarks: "\n<p>You must successfully authenticate before calling this method. Clients specify the impersonation level when they request authentication by calling one of the <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient\"></see> or <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient\"></see> methods. If you authenticate without specifying a <xref href=\"System.Security.Principal.TokenImpersonationLevel\" data-throw-if-not-resolved=\"false\"></xref> , <xref href=\"System.Security.Principal.TokenImpersonationLevel.Identification\" data-throw-if-not-resolved=\"false\"></xref> is used.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#1"
  syntax:
    content: public virtual Principal.TokenImpersonationLevel ImpersonationLevel { get; }
    content.vb: Public Overridable ReadOnly Property ImpersonationLevel As Principal.TokenImpersonationLevel
    parameters: []
    return:
      type: System.Security.Principal.TokenImpersonationLevel
      description: "\n<p>One of the <xref href=\"System.Security.Principal.TokenImpersonationLevel\" data-throw-if-not-resolved=\"false\"></xref> values.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>Authentication failed or has not occurred.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.IsAuthenticated
  commentId: P:System.Net.Security.NegotiateStream.IsAuthenticated
  id: IsAuthenticated
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: IsAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsAuthenticated
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsAuthenticated
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 229
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether authentication was successful.</p>\n"
  remarks: "\n<p>Clients authenticate by calling the <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient\"></see> or <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient\"></see> methods. Servers authenticate by calling the <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer\"></see> or <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer\"></see> methods.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#1"
  syntax:
    content: public override bool IsAuthenticated { get; }
    content.vb: Public Overrides ReadOnly Property IsAuthenticated As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if successful authentication occurred; otherwise, <strong>false</strong>. </p>\n"
  overridden: System.Net.Security.AuthenticatedStream.IsAuthenticated
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.IsEncrypted
  commentId: P:System.Net.Security.NegotiateStream.IsEncrypted
  id: IsEncrypted
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: IsEncrypted
  fullName: System.Net.Security.NegotiateStream.IsEncrypted
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsEncrypted
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 259
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether this <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> uses data encryption.</p>\n"
  remarks: "\n<p>Encryption helps to protect the privacy of the data; namely, it helps to ensure that while data is in transit it cannot be deciphered by third parties. </p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#1"
  syntax:
    content: public override bool IsEncrypted { get; }
    content.vb: Public Overrides ReadOnly Property IsEncrypted As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if data is encrypted before being transmitted over the network and decrypted when it reaches the remote endpoint; otherwise, <strong>false</strong>.</p>\n"
  overridden: System.Net.Security.AuthenticatedStream.IsEncrypted
  seealso:
  - type: System.Net.Security.ProtectionLevel
    commentId: T:System.Net.Security.ProtectionLevel
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  commentId: P:System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  id: IsMutuallyAuthenticated
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: IsMutuallyAuthenticated
  fullName: System.Net.Security.NegotiateStream.IsMutuallyAuthenticated
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsMutuallyAuthenticated
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 244
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether both the server and the client have been authenticated.</p>\n"
  remarks: "\n<p>Mutual authentication is specified by the client when the client wants the server to provide credentials for authentication. By default, clients request mutual authentication.</p>\n<p>The Negotiate protocol selects either NTLM or Kerberos depending on the security protocols supported by the client and server. NTLM does not support mutual authentication.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#1"
  syntax:
    content: public override bool IsMutuallyAuthenticated { get; }
    content.vb: Public Overrides ReadOnly Property IsMutuallyAuthenticated As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the server has been authenticated; otherwise, <strong>false</strong>.</p>\n"
  overridden: System.Net.Security.AuthenticatedStream.IsMutuallyAuthenticated
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.IsServer
  commentId: P:System.Net.Security.NegotiateStream.IsServer
  id: IsServer
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: IsServer
  fullName: System.Net.Security.NegotiateStream.IsServer
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsServer
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 289
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether the local side of the connection used by this <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> was authenticated as the server.</p>\n"
  remarks: "\n<p>If authentication failed or did not occur, this property returns <strong>false</strong>.</p>\n<p>To authenticate as the server, call the <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer\"></see> or <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer\"></see> methods.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#1"
  syntax:
    content: public override bool IsServer { get; }
    content.vb: Public Overrides ReadOnly Property IsServer As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the local endpoint was successfully authenticated as the server side of the authenticated connection; otherwise, <strong>false</strong>.</p>\n"
  overridden: System.Net.Security.AuthenticatedStream.IsServer
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.IsSigned
  commentId: P:System.Net.Security.NegotiateStream.IsSigned
  id: IsSigned
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: IsSigned
  fullName: System.Net.Security.NegotiateStream.IsSigned
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: IsSigned
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 274
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets a <xref href=\"System.Boolean\" data-throw-if-not-resolved=\"false\"></xref> value that indicates whether the data sent using this stream is signed.</p>\n"
  remarks: "\n<p>Data signing helps to protect the integrity of the data; namely, it helps the recipient determine whether the data has been tampered with while in transit. </p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#1"
  syntax:
    content: public override bool IsSigned { get; }
    content.vb: Public Overrides ReadOnly Property IsSigned As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the data is signed before being transmitted; otherwise, <strong>false</strong>.</p>\n"
  overridden: System.Net.Security.AuthenticatedStream.IsSigned
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.Length
  commentId: P:System.Net.Security.NegotiateStream.Length
  id: Length
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: Length
  fullName: System.Net.Security.NegotiateStream.Length
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Length
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 399
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets the length of the underlying stream.</p>\n"
  remarks: "\n<p>This property returns the value returned by invoking the <xref href=\"System.IO.Stream.Length\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. If the underlying stream is not seekable, this property will typically throw an exception. The run-time type of the underlying stream determines the run-time type of the exception that is thrown.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override long Length { get; }
    content.vb: Public Overrides ReadOnly Property Length As Long
    parameters: []
    return:
      type: System.Int64
      description: "\n<p>A <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> that specifies the length of the underlying stream.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Getting the value of this property is not supported when the underlying stream is a <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  modifiers.vb:
  - Public
  - Overrides
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.Position
  commentId: P:System.Net.Security.NegotiateStream.Position
  id: Position
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: Position
  fullName: System.Net.Security.NegotiateStream.Position
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Position
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 407
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets or sets the current position in the underlying stream.</p>\n"
  remarks: "\n<p>This property returns the value returned by invoking the <xref href=\"System.IO.Stream.Position\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. If the underlying stream is not seekable, this property will typically throw an exception. The run-time type of the underlying stream determines the run-time type of the exception that is thrown.</p>\n"
  syntax:
    content: public override long Position { get; set; }
    content.vb: Public Overrides Property Position As Long
    parameters: []
    return:
      type: System.Int64
      description: "\n<p>A <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> that specifies the current position in the underlying stream.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Setting this property is not supported.</p>\n<p>- or -</p>\n<p>Getting the value of this property is not supported when the underlying stream is a <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  - set
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Net.Security.NegotiateStream.ReadTimeout
  commentId: P:System.Net.Security.NegotiateStream.ReadTimeout
  id: ReadTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: ReadTimeout
  fullName: System.Net.Security.NegotiateStream.ReadTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: ReadTimeout
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 375
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets or sets the amount of time a read operation blocks waiting for data.</p>\n"
  remarks: "\n<p>This property returns the value returned by invoking the <xref href=\"System.IO.Stream.ReadTimeout\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. When you set this property, the <xref href=\"System.IO.Stream.ReadTimeout\" data-throw-if-not-resolved=\"false\"></xref> value on the underlying stream is set to the specified value.</p>\n<p>If the underlying stream is a <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Security.NegotiateStream.ReadTimeout\" data-throw-if-not-resolved=\"false\"></xref> is in milliseconds and is set to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> by default so that read operations do not time out.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override int ReadTimeout { get; set; }
    content.vb: Public Overrides Property ReadTimeout As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> that specifies the amount of time that will elapse before a read operation fails. </p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  - set
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Net.Security.NegotiateStream.RemoteIdentity
  commentId: P:System.Net.Security.NegotiateStream.RemoteIdentity
  id: RemoteIdentity
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: RemoteIdentity
  fullName: System.Net.Security.NegotiateStream.RemoteIdentity
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: RemoteIdentity
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 319
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets information about the identity of the remote party sharing this authenticated stream.</p>\n"
  remarks: "\n<p>When accessed by the client, this property returns a <xref href=\"System.Security.Principal.GenericIdentity\" data-throw-if-not-resolved=\"false\"></xref> containing the Service Principal Name (SPN) of the server and the authentication protocol used. When accessed by the server, this property returns a <xref href=\"System.Security.Principal.WindowsIdentity\" data-throw-if-not-resolved=\"false\"></xref> that describes the client. If the <xref href=\"System.Security.Principal.WindowsIdentity\" data-throw-if-not-resolved=\"false\"></xref> is not available, client information is returned to the server in a <xref href=\"System.Security.Principal.GenericIdentity\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoAsyncServer#2"
  syntax:
    content: public virtual Principal.IIdentity RemoteIdentity { get; }
    content.vb: Public Overridable ReadOnly Property RemoteIdentity As Principal.IIdentity
    parameters: []
    return:
      type: System.Security.Principal.IIdentity
      description: "\n<p>An <xref href=\"System.Security.Principal.IIdentity\" data-throw-if-not-resolved=\"false\"></xref> object that describes the identity of the remote endpoint.</p>\n"
  exceptions:
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>Authentication failed or has not occurred.</p>\n"
  modifiers.csharp:
  - public
  - virtual
  - get
  modifiers.vb:
  - Public
  - Overridable
  - ReadOnly
- uid: System.Net.Security.NegotiateStream.WriteTimeout
  commentId: P:System.Net.Security.NegotiateStream.WriteTimeout
  id: WriteTimeout
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: WriteTimeout
  fullName: System.Net.Security.NegotiateStream.WriteTimeout
  type: Property
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: WriteTimeout
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 387
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Gets or sets the amount of time a write operation blocks waiting for data.</p>\n"
  remarks: "\n<p>This property returns the value returned by invoking the <xref href=\"System.IO.Stream.WriteTimeout\" data-throw-if-not-resolved=\"false\"></xref> property on the underlying stream. For set operations, the specified value sets the <xref href=\"System.IO.Stream.WriteTimeout\" data-throw-if-not-resolved=\"false\"></xref> value on the underlying stream.</p>\n<p>If the underlying stream is a <xref href=\"System.Net.Sockets.NetworkStream\" data-throw-if-not-resolved=\"false\"></xref>, <xref href=\"System.Net.Security.NegotiateStream.WriteTimeout\" data-throw-if-not-resolved=\"false\"></xref> is in milliseconds and is set to <xref href=\"System.Threading.Timeout.Infinite\" data-throw-if-not-resolved=\"false\"></xref> by default so that write operations do not time out.</p>\n"
  example:
  - "\n<p>The following code example demonstrates displaying the value of this property.</p>NclNegoSyncClient#2"
  syntax:
    content: public override int WriteTimeout { get; set; }
    content.vb: Public Overrides Property WriteTimeout As Integer
    parameters: []
    return:
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> that specifies the amount of time that will elapse before a write operation fails. </p>\n"
  modifiers.csharp:
  - public
  - override
  - get
  - set
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync
  id: AuthenticateAsClientAsync
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsClientAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync()
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsClientAsync
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 175
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Called by clients to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.</p>\n"
  remarks: "\n<p>The authentication uses the client's <xref href=\"System.Net.CredentialCache.DefaultCredentials\" data-throw-if-not-resolved=\"false\"></xref>. No Service Principal Name (SPN) is specified for the server. The impersonation level is <xref href=\"System.Security.Principal.TokenImpersonationLevel.Identification\" data-throw-if-not-resolved=\"false\"></xref>, the security level is <xref href=\"System.Net.Security.ProtectionLevel.EncryptAndSign\" data-throw-if-not-resolved=\"false\"></xref>, and mutual authentication is requested. The <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class will construct the SPN used for mutual authentication. </p>\n<p>When authentication succeeds, you must check the <xref href=\"System.Net.Security.NegotiateStream.IsEncrypted\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Security.NegotiateStream.IsSigned\" data-throw-if-not-resolved=\"false\"></xref> properties to determine what security services are used by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>. Check the <xref href=\"System.Net.Security.NegotiateStream.IsMutuallyAuthenticated\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether mutual authentication occurred.</p>\n<p>If the authentication fails, you receive an <xref href=\"System.Security.Authentication.AuthenticationException\" data-throw-if-not-resolved=\"false\"></xref> or an <xref href=\"System.Security.Authentication.InvalidCredentialException\" data-throw-if-not-resolved=\"false\"></xref>. In this case, you can retry the authentication with a different credential.</p>\n"
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsClientAsync()
    content.vb: Public Overridable Function AuthenticateAsClientAsync As Threading.Tasks.Task
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation.</p>\n"
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "\n<p>The authentication failed. You can use this object to retry the authentication.</p>\n"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "\n<p>The authentication failed. You can use this object to retry the authentication.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>This object has been closed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>Authentication has already occurred.</p>\n<p>- or -</p>\n<p>This stream was used previously to attempt authentication as the server. You cannot use the stream to retry authentication as the client.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.String)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.String)
  id: AuthenticateAsClientAsync(NetworkCredential,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsClientAsync(NetworkCredential, String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential, System.String)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsClientAsync
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 180
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName)
    content.vb: Public Overridable Function AuthenticateAsClientAsync(credential As NetworkCredential, targetName As String) As Threading.Tasks.Task
    parameters:
    - id: credential
      type: NetworkCredential
    - id: targetName
      type: System.String
    return:
      type: System.Threading.Tasks.Task
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  id: AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsClientAsync(NetworkCredential, ChannelBinding, String)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsClientAsync
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 50
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName)
    content.vb: Public Overridable Function AuthenticateAsClientAsync(credential As NetworkCredential, binding As ChannelBinding, targetName As String) As Threading.Tasks.Task
    parameters:
    - id: credential
      type: NetworkCredential
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
    - id: targetName
      type: System.String
    return:
      type: System.Threading.Tasks.Task
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClientAsync(NetworkCredential,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsClientAsync(NetworkCredential, String, ProtectionLevel, Principal.TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsClientAsync
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 51
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsClientAsync(NetworkCredential credential, string targetName, ProtectionLevel requiredProtectionLevel, Principal.TokenImpersonationLevel allowedImpersonationLevel)
    content.vb: Public Overridable Function AuthenticateAsClientAsync(credential As NetworkCredential, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As Principal.TokenImpersonationLevel) As Threading.Tasks.Task
    parameters:
    - id: credential
      type: NetworkCredential
    - id: targetName
      type: System.String
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
    return:
      type: System.Threading.Tasks.Task
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsClientAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ChannelBinding,System.String,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsClientAsync(NetworkCredential, ChannelBinding, String, ProtectionLevel, Principal.TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsClientAsync(NetworkCredential, System.Security.Authentication.ExtendedProtection.ChannelBinding, System.String, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsClientAsync
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 52
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsClientAsync(NetworkCredential credential, ChannelBinding binding, string targetName, ProtectionLevel requiredProtectionLevel, Principal.TokenImpersonationLevel allowedImpersonationLevel)
    content.vb: Public Overridable Function AuthenticateAsClientAsync(credential As NetworkCredential, binding As ChannelBinding, targetName As String, requiredProtectionLevel As ProtectionLevel, allowedImpersonationLevel As Principal.TokenImpersonationLevel) As Threading.Tasks.Task
    parameters:
    - id: credential
      type: NetworkCredential
    - id: binding
      type: System.Security.Authentication.ExtendedProtection.ChannelBinding
    - id: targetName
      type: System.String
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
    - id: allowedImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
    return:
      type: System.Threading.Tasks.Task
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync
  id: AuthenticateAsServerAsync
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsServerAsync()
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync()
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsServerAsync
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 206
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation.</p>\n"
  remarks: "\n<p>The authentication uses the server's <xref href=\"System.Net.CredentialCache.DefaultCredentials\" data-throw-if-not-resolved=\"false\"></xref>. No Service Principal Name (SPN) is specified for the server. The impersonation level is <xref href=\"System.Security.Principal.TokenImpersonationLevel.Identification\" data-throw-if-not-resolved=\"false\"></xref>, and the security level is <xref href=\"System.Net.Security.ProtectionLevel.EncryptAndSign\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When authentication succeeds, you must check the <xref href=\"System.Net.Security.NegotiateStream.IsEncrypted\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Security.NegotiateStream.IsSigned\" data-throw-if-not-resolved=\"false\"></xref> properties to determine what security services are used by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>. Check the <xref href=\"System.Net.Security.NegotiateStream.IsMutuallyAuthenticated\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether mutual authentication occurred.</p>\n<p>If the authentication fails, you receive an <xref href=\"System.Security.Authentication.AuthenticationException\" data-throw-if-not-resolved=\"false\"></xref> or an <xref href=\"System.Security.Authentication.InvalidCredentialException\" data-throw-if-not-resolved=\"false\"></xref>. In this case, you can retry the authentication with a different credential. </p>\n"
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsServerAsync()
    content.vb: Public Overridable Function AuthenticateAsServerAsync As Threading.Tasks.Task
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation.</p>\n"
  exceptions:
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "\n<p>The authentication failed. You can use this object to retry the authentication.</p>\n"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "\n<p>The authentication failed. You can use this object to retry the authentication.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>This object has been closed.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows 95 and Windows 98 are not supported.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  id: AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsServerAsync(ExtendedProtectionPolicy)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsServerAsync
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 211
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Called by servers to authenticate the client, and optionally the server, in a client-server connection as an asynchronous operation. The authentication process uses the specified extended protection policy.</p>\n"
  remarks: "\n<p>The authentication uses the server's <xref href=\"System.Net.CredentialCache.DefaultCredentials\" data-throw-if-not-resolved=\"false\"></xref>. No Service Principal Name (SPN) is specified for the server. The impersonation level is <xref href=\"System.Security.Principal.TokenImpersonationLevel.Identification\" data-throw-if-not-resolved=\"false\"></xref>, and the security level is <xref href=\"System.Net.Security.ProtectionLevel.EncryptAndSign\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>If the <em>policy</em> parameter is <strong>null</strong>, then an extended protection policy is used that has <xref href=\"System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.PolicyEnforcement\" data-throw-if-not-resolved=\"false\"></xref> set to <xref href=\"System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Never\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>When authentication succeeds, you must check the <xref href=\"System.Net.Security.NegotiateStream.IsEncrypted\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Net.Security.NegotiateStream.IsSigned\" data-throw-if-not-resolved=\"false\"></xref> properties to determine what security services are used by the <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>. Check the <xref href=\"System.Net.Security.NegotiateStream.IsMutuallyAuthenticated\" data-throw-if-not-resolved=\"false\"></xref> property to determine whether mutual authentication occurred.</p>\n<p>If the authentication fails, you receive an <xref href=\"System.Security.Authentication.AuthenticationException\" data-throw-if-not-resolved=\"false\"></xref> or an <xref href=\"System.Security.Authentication.InvalidCredentialException\" data-throw-if-not-resolved=\"false\"></xref>. In this case, you can retry the authentication with a different credential.</p>\n"
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsServerAsync(ExtendedProtectionPolicy policy)
    content.vb: Public Overridable Function AuthenticateAsServerAsync(policy As ExtendedProtectionPolicy) As Threading.Tasks.Task
    parameters:
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
      description: "\n<p>The <xref href=\"System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy\" data-throw-if-not-resolved=\"false\"></xref> that is used for extended protection. </p>\n"
    return:
      type: System.Threading.Tasks.Task
      description: "\n<p>Returns <xref href=\"System.Threading.Tasks.Task\" data-throw-if-not-resolved=\"false\"></xref></p>\n<p>The task object representing the asynchronous operation.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>The <xref href=\"System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomChannelBinding\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy.CustomServiceNames\" data-throw-if-not-resolved=\"false\"></xref> on the extended protection policy passed in the <em>policy</em> parameter are both <strong>null</strong>.</p>\n"
  - type: System.Security.Authentication.AuthenticationException
    commentId: T:System.Security.Authentication.AuthenticationException
    description: "\n<p>The authentication failed. You can use this object to retry the authentication.</p>\n"
  - type: System.Security.Authentication.InvalidCredentialException
    commentId: T:System.Security.Authentication.InvalidCredentialException
    description: "\n<p>The authentication failed. You can use this object to retry the authentication.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Windows 95 and Windows 98 are not supported.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>This object has been closed.</p>\n"
  - type: System.PlatformNotSupportedException
    commentId: T:System.PlatformNotSupportedException
    description: "\n<p>The <em>policy</em> parameter was set to <xref href=\"System.Security.Authentication.ExtendedProtection.PolicyEnforcement.Always\" data-throw-if-not-resolved=\"false\"></xref> on a platform that does not support extended protection.</p>\n"
  seealso:
  - type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
    commentId: T:System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServerAsync(NetworkCredential,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsServerAsync(NetworkCredential, ProtectionLevel, Principal.TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsServerAsync
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 55
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsServerAsync(NetworkCredential credential, ProtectionLevel requiredProtectionLevel, Principal.TokenImpersonationLevel requiredImpersonationLevel)
    content.vb: Public Overridable Function AuthenticateAsServerAsync(credential As NetworkCredential, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As Principal.TokenImpersonationLevel) As Threading.Tasks.Task
    parameters:
    - id: credential
      type: NetworkCredential
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
    return:
      type: System.Threading.Tasks.Task
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  commentId: M:System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  id: AuthenticateAsServerAsync(NetworkCredential,System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy,System.Net.Security.ProtectionLevel,System.Security.Principal.TokenImpersonationLevel)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: AuthenticateAsServerAsync(NetworkCredential, ExtendedProtectionPolicy, ProtectionLevel, Principal.TokenImpersonationLevel)
  fullName: System.Net.Security.NegotiateStream.AuthenticateAsServerAsync(NetworkCredential, System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy, System.Net.Security.ProtectionLevel, System.Security.Principal.TokenImpersonationLevel)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: AuthenticateAsServerAsync
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 56
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  syntax:
    content: public virtual Threading.Tasks.Task AuthenticateAsServerAsync(NetworkCredential credential, ExtendedProtectionPolicy policy, ProtectionLevel requiredProtectionLevel, Principal.TokenImpersonationLevel requiredImpersonationLevel)
    content.vb: Public Overridable Function AuthenticateAsServerAsync(credential As NetworkCredential, policy As ExtendedProtectionPolicy, requiredProtectionLevel As ProtectionLevel, requiredImpersonationLevel As Principal.TokenImpersonationLevel) As Threading.Tasks.Task
    parameters:
    - id: credential
      type: NetworkCredential
    - id: policy
      type: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
    - id: requiredProtectionLevel
      type: System.Net.Security.ProtectionLevel
    - id: requiredImpersonationLevel
      type: System.Security.Principal.TokenImpersonationLevel
    return:
      type: System.Threading.Tasks.Task
  modifiers.csharp:
  - public
  - virtual
  modifiers.vb:
  - Public
  - Overridable
- uid: System.Net.Security.NegotiateStream.Flush
  commentId: M:System.Net.Security.NegotiateStream.Flush
  id: Flush
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: Flush()
  fullName: System.Net.Security.NegotiateStream.Flush()
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Flush
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 429
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Causes any buffered data to be written to the underlying device.</p>\n"
  remarks: "\n<p>This method invokes <xref href=\"System.IO.Stream.Flush\" data-throw-if-not-resolved=\"false\"></xref> on the underlying stream.</p>\n"
  example:
  - "\n<p>The following code example demonstrates flushing the stream.</p>NclNegoSyncClient#4"
  syntax:
    content: public override void Flush()
    content.vb: Public Overrides Sub Flush
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)
  id: Read(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: Read(Byte[], Int32, Int32)
  fullName: System.Net.Security.NegotiateStream.Read(System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Read
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 460
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Reads data from this stream and stores it in the specified array.</p>\n"
  remarks: "\n<p>The method reads a maximum of <em>count</em> bytes from the current stream and stores them in <em>buffer</em> beginning at <em>offset</em>.</p>\n<p>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient\"></see>, <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient\"></see>, <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer\"></see>, or <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer\"></see> methods.</p>\n<p>To perform this operation asynchronously, use the <xref href=\"System.Net.Security.NegotiateStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)\" data-throw-if-not-resolved=\"false\"></xref> method. </p>\n"
  example:
  - "\n<p>The following code example demonstrates reading from a <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>NclNegoSyncServer#1"
  syntax:
    content: public override int Read(byte[] buffer, int offset, int count)
    content.vb: Public Overrides Function Read(buffer As Byte(), offset As Integer, count As Integer) As Integer
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>A <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> array that receives the bytes read from the stream.</p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> containing the zero-based location in <em>buffer</em> at which to begin storing the data read from this stream.</p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> containing the maximum number of bytes to read from the stream.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> value that specifies the number of bytes read from the underlying stream. When there is no more data to be read, returns 0.</p>\n"
  exceptions:
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>The read operation failed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>Authentication has not occurred.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>A <xref href=\"System.Net.Security.NegotiateStream.Read(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> operation is already in progress.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
  fullName.vb: System.Net.Security.NegotiateStream.Read(System.Byte(), System.Int32, System.Int32)
  name.vb: Read(Byte(), Int32, Int32)
- uid: System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  commentId: M:System.Net.Security.NegotiateStream.Seek(System.Int64,System.IO.SeekOrigin)
  id: Seek(System.Int64,System.IO.SeekOrigin)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: Seek(Int64, IO.SeekOrigin)
  fullName: System.Net.Security.NegotiateStream.Seek(System.Int64, System.IO.SeekOrigin)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/ref/System.Net.Security.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Seek
    path: src/System.Net.Security/ref/System.Net.Security.cs
    startLine: 59
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Throws <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  remarks: "\n<p>Do not call this method. It is inherited, but is not supported by <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  syntax:
    content: public override long Seek(long offset, IO.SeekOrigin origin)
    content.vb: Public Overrides Function Seek(offset As Long, origin As IO.SeekOrigin) As Long
    parameters:
    - id: offset
      type: System.Int64
      description: "\n<p>This value is ignored.</p>\n"
    - id: origin
      type: System.IO.SeekOrigin
      description: "\n<p>This value is ignored.</p>\n"
    return:
      type: System.Int64
      description: "\n<p>Always throws a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  exceptions:
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>Seeking is not supported on <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Net.Security.NegotiateStream.SetLength(System.Int64)
  commentId: M:System.Net.Security.NegotiateStream.SetLength(System.Int64)
  id: SetLength(System.Int64)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: SetLength(Int64)
  fullName: System.Net.Security.NegotiateStream.SetLength(System.Int64)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: SetLength
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 419
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Sets the length of the underlying stream.</p>\n"
  syntax:
    content: public override void SetLength(long value)
    content.vb: Public Overrides Sub SetLength(value As Long)
    parameters:
    - id: value
      type: System.Int64
      description: "\n<p>An <xref href=\"System.Int64\" data-throw-if-not-resolved=\"false\"></xref> value that specifies the length of the stream.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
- uid: System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  commentId: M:System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)
  id: Write(System.Byte[],System.Int32,System.Int32)
  parent: System.Net.Security.NegotiateStream
  langs:
  - csharp
  - vb
  name: Write(Byte[], Int32, Int32)
  fullName: System.Net.Security.NegotiateStream.Write(System.Byte[], System.Int32, System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Write
    path: src/System.Net.Security/src/System/Net/SecureProtocols/NegotiateStream.cs
    startLine: 479
  assemblies:
  - System.Net.Security
  namespace: System.Net.Security
  summary: "\n<p>Write the specified number of <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref>s to the underlying stream using the specified buffer and offset.</p>\n"
  remarks: "\n<p>If encryption, signing, or encryption and signing are enabled, this method reads the data from buffer, encrypts, signs, or encrypts and signs it, and transmits it using the underlying stream. If no security services such as data encryption or signing are in use, this method invokes <xref href=\"System.IO.Stream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> on the underlying stream.</p>\n<p>This method blocks while the write operation completes. To prevent blocking while the operation completes, use the <xref href=\"System.Net.Security.NegotiateStream.Write(System.Byte[],System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method.</p>\n<p>You cannot call this method until you have successfully authenticated. To authenticate, call one of the <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsClient\"></see>, <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsClient\"></see>, <see cref=\"Overload:System.Net.Security.NegotiateStream.AuthenticateAsServer\"></see>, or <see cref=\"Overload:System.Net.Security.NegotiateStream.BeginAuthenticateAsServer\"></see> methods.</p>\n<p>The <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref> class does not support multiple simultaneous write operations. If you attempt to start a write operation while another write operation is already executing on the same stream, a <xref href=\"System.NotSupportedException\" data-throw-if-not-resolved=\"false\"></xref> exception will be thrown.</p>\n"
  example:
  - "\n<p>The following code example demonstrates writing to a <xref href=\"System.Net.Security.NegotiateStream\" data-throw-if-not-resolved=\"false\"></xref>.</p>NclNegoSyncClient#4"
  syntax:
    content: public override void Write(byte[] buffer, int offset, int count)
    content.vb: Public Overrides Sub Write(buffer As Byte(), offset As Integer, count As Integer)
    parameters:
    - id: buffer
      type: System.Byte[]
      description: "\n<p>A <xref href=\"System.Byte\" data-throw-if-not-resolved=\"false\"></xref> array that supplies the bytes written to the stream.</p>\n"
    - id: offset
      type: System.Int32
      description: "\n<p>An <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> containing the zero-based location in<em> buffer</em> at which to begin reading bytes to be written to the stream.</p>\n"
    - id: count
      type: System.Int32
      description: "\n<p>A <xref href=\"System.Int32\" data-throw-if-not-resolved=\"false\"></xref> containing the number of bytes to read from <em>buffer</em>.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>buffer</em> is <strong>null</strong>.</p>\n"
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>offset is less than 0</em>.</p>\n<p>- or -</p>\n<p>\n<em>offset</em> is greater than the length of <em>buffer</em>.</p>\n<p>- or -</p>\n<p>\n<em>offset</em> plus count is greater than the length of <em>buffer</em>.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>The write operation failed.</p>\n<p>- or -</p>\n<p>Encryption is in use, but the data could not be encrypted.</p>\n"
  - type: System.NotSupportedException
    commentId: T:System.NotSupportedException
    description: "\n<p>There is already a write operation in progress.</p>\n"
  - type: System.ObjectDisposedException
    commentId: T:System.ObjectDisposedException
    description: "\n<p>This object has been closed.</p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>Authentication has not occurred.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
  fullName.vb: System.Net.Security.NegotiateStream.Write(System.Byte(), System.Int32, System.Int32)
  name.vb: Write(Byte(), Int32, Int32)
references:
- uid: System.Net.Security
  isExternal: false
  name: System.Net.Security
  fullName: System.Net.Security
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System.Net.Security.AuthenticatedStream
  parent: System.Net.Security
  isExternal: false
  name: AuthenticatedStream
  fullName: System.Net.Security.AuthenticatedStream
- uid: System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: LeaveInnerStreamOpen
  fullName: System.Net.Security.AuthenticatedStream.LeaveInnerStreamOpen
- uid: System.Net.Security.AuthenticatedStream.InnerStream
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: InnerStream
  fullName: System.Net.Security.AuthenticatedStream.InnerStream
- uid: System.Net.Security.AuthenticatedStream.Dispose(System.Boolean)
  parent: System.Net.Security.AuthenticatedStream
  isExternal: true
  name: Dispose(Boolean)
  fullName: System.Net.Security.AuthenticatedStream.Dispose(System.Boolean)
  spec.csharp:
  - uid: System.Net.Security.AuthenticatedStream.Dispose(System.Boolean)
    name: Dispose
    fullName: System.Net.Security.AuthenticatedStream.Dispose
  - name: (
    fullName: (
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Net.Security.AuthenticatedStream.Dispose(System.Boolean)
    name: Dispose
    fullName: System.Net.Security.AuthenticatedStream.Dispose
  - name: (
    fullName: (
  - uid: System.Boolean
    name: Boolean
    fullName: System.Boolean
    isExternal: true
  - name: )
    fullName: )
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.IO.Stream
  parent: System.IO
  isExternal: false
  name: IO.Stream
  fullName: System.IO.Stream
- uid: System.IO
  isExternal: false
  name: System.IO
  fullName: System.IO
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Security.Principal.TokenImpersonationLevel
  parent: System.Security.Principal
  isExternal: false
  name: TokenImpersonationLevel
  fullName: System.Security.Principal.TokenImpersonationLevel
- uid: System.Security.Principal
  isExternal: false
  name: System.Security.Principal
  fullName: System.Security.Principal
- uid: System.Net.Security.AuthenticatedStream.IsAuthenticated
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: IsAuthenticated
  fullName: System.Net.Security.AuthenticatedStream.IsAuthenticated
- uid: System.Net.Security.AuthenticatedStream.IsEncrypted
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: IsEncrypted
  fullName: System.Net.Security.AuthenticatedStream.IsEncrypted
- uid: System.Net.Security.AuthenticatedStream.IsMutuallyAuthenticated
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: IsMutuallyAuthenticated
  fullName: System.Net.Security.AuthenticatedStream.IsMutuallyAuthenticated
- uid: System.Net.Security.AuthenticatedStream.IsServer
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: IsServer
  fullName: System.Net.Security.AuthenticatedStream.IsServer
- uid: System.Net.Security.AuthenticatedStream.IsSigned
  parent: System.Net.Security.AuthenticatedStream
  isExternal: false
  name: IsSigned
  fullName: System.Net.Security.AuthenticatedStream.IsSigned
- uid: System.Int64
  parent: System
  isExternal: false
  name: Int64
  fullName: System.Int64
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.Security.Principal.IIdentity
  parent: System.Security.Principal
  isExternal: false
  name: IIdentity
  fullName: System.Security.Principal.IIdentity
- uid: System.Threading.Tasks.Task
  parent: System.Threading.Tasks
  isExternal: false
  name: Threading.Tasks.Task
  fullName: System.Threading.Tasks.Task
- uid: System.Threading.Tasks
  isExternal: false
  name: System.Threading.Tasks
  fullName: System.Threading.Tasks
- uid: NetworkCredential
  isExternal: true
  name: NetworkCredential
  fullName: NetworkCredential
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Security.Authentication.ExtendedProtection.ChannelBinding
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ChannelBinding
  fullName: System.Security.Authentication.ExtendedProtection.ChannelBinding
- uid: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: System.Security.Authentication.ExtendedProtection
  fullName: System.Security.Authentication.ExtendedProtection
- uid: System.Net.Security.ProtectionLevel
  parent: System.Net.Security
  isExternal: false
  name: ProtectionLevel
  fullName: System.Net.Security.ProtectionLevel
- uid: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
  parent: System.Security.Authentication.ExtendedProtection
  isExternal: false
  name: ExtendedProtectionPolicy
  fullName: System.Security.Authentication.ExtendedProtection.ExtendedProtectionPolicy
- uid: System.Byte[]
  isExternal: false
  name: Byte[]
  fullName: System.Byte[]
  fullname.vb: System.Byte()
  name.vb: Byte()
  spec.csharp:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: '[]'
    fullName: '[]'
  spec.vb:
  - uid: System.Byte
    name: Byte
    fullName: System.Byte
  - name: ()
    fullName: ()
- uid: System.IO.SeekOrigin
  parent: System.IO
  isExternal: false
  name: SeekOrigin
  fullName: System.IO.SeekOrigin
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
- uid: System.NotSupportedException
  parent: System
  isExternal: false
  name: NotSupportedException
  fullName: System.NotSupportedException
- uid: System.Security.Authentication.AuthenticationException
  parent: System.Security.Authentication
  isExternal: false
  name: AuthenticationException
  fullName: System.Security.Authentication.AuthenticationException
- uid: System.Security.Authentication.InvalidCredentialException
  isExternal: false
  name: InvalidCredentialException
  fullName: System.Security.Authentication.InvalidCredentialException
- uid: System.ObjectDisposedException
  isExternal: false
  name: ObjectDisposedException
  fullName: System.ObjectDisposedException
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.PlatformNotSupportedException
  isExternal: false
  name: PlatformNotSupportedException
  fullName: System.PlatformNotSupportedException
- uid: System.IO.IOException
  parent: System.IO
  isExternal: false
  name: IOException
  fullName: System.IO.IOException
