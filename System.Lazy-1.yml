items:
- uid: System.Lazy`1
  commentId: T:System.Lazy`1
  id: Lazy`1
  parent: System
  children:
  - System.Lazy`1.#ctor
  - System.Lazy`1.#ctor(System.Boolean)
  - System.Lazy`1.#ctor(System.Func{`0})
  - System.Lazy`1.#ctor(System.Func{`0},System.Boolean)
  - System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)
  - System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)
  - System.Lazy`1.IsValueCreated
  - System.Lazy`1.ToString
  - System.Lazy`1.Value
  langs:
  - csharp
  - vb
  name: Lazy<T>
  fullName: System.Lazy<T>
  type: Class
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Lazy
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 48
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Provides support for lazy initialization.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class to provide lazy initialization with access from multiple threads. </p>\n<p>The example uses the <xref href=\"System.Lazy`1.#ctor(System.Func{`0})\" data-throw-if-not-resolved=\"false\"></xref> constructor. It also demonstrates the use of the <xref href=\"System.Lazy`1.#ctor(System.Func{`0},System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <strong>true</strong> for <em>isThreadSafe</em>) and the <xref href=\"System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>). To switch to a different constructor, just change which constructors are commented out. </p>\n<p>For an example that demonstrates exception caching using the same constructors, see the <xref href=\"System.Lazy`1.#ctor(System.Func{`0})\" data-throw-if-not-resolved=\"false\"></xref> constructor. </p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily by one of several threads. The four key sections of code illustrate the creation of the initializer, the factory method, the actual initialization, and the constructor of the <code>LargeObject</code> class, which displays a message when the object is created. At the beginning of the <code>Main</code> method, the example creates the thread-safe lazy initializer for <code>LargeObject</code>: </p>System.Lazy`1#NewLazy<p>The factory method shows the creation of the object, with a placeholder for further initialization: </p>System.Lazy`1#FactoryFunc<p>Note that the first two code sections could be combined by using a lambda function, as shown here: </p>System.Lazy`1#InitWithLambda<p>The example pauses, to indicate that an indeterminate period may elapse before lazy initialization occurs. When you press the Enter key, the example creates and starts three threads. The <code>ThreadProc</code> method that's used by all three threads calls the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property. The first time this happens, the <code>LargeObject</code> instance is created: </p>System.Lazy`1#ValueProp<p>The constructor of the <code>LargeObject</code> class, which includes the last key section of code, displays a message and records the identity of the initializing thread. The output from the program appears at the end of the full code listing. </p>System.Lazy`1#LargeCtor<p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1#All"
  syntax:
    content: >-
      [Serializable]

      [ComVisible(false)]

      [DebuggerTypeProxy(typeof (System_LazyDebugView<>))]

      [DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")]

      public class Lazy<T>
    content.vb: >-
      <Serializable>

      <ComVisible(False)>

      <DebuggerTypeProxy(GetType(System_LazyDebugView(Of )))>

      <DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")>

      Public Class Lazy(Of T)
    typeParameters:
    - id: T
      description: "\n<p>The type of object that is being lazily initialized.</p>\n"
  seealso:
  - type: System.Threading.LazyThreadSafetyMode
    commentId: T:System.Threading.LazyThreadSafetyMode
  inheritance:
  - System.Object
  inheritedMembers:
  - System.Object.Equals(System.Object)
  - System.Object.Equals(System.Object,System.Object)
  - System.Object.ReferenceEquals(System.Object,System.Object)
  - System.Object.GetHashCode
  - System.Object.GetType
  - System.Object.MemberwiseClone
  modifiers.csharp:
  - public
  - class
  modifiers.vb:
  - Public
  - Class
  fullName.vb: System.Lazy(Of T)
  name.vb: Lazy(Of T)
  nameWithType: Lazy<T>
  nameWithType.vb: Lazy(Of T)
- uid: System.Lazy`1.#ctor
  commentId: M:System.Lazy`1.#ctor
  id: '#ctor'
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Lazy()
  fullName: System.Lazy<T>.Lazy()
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 120
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class. When lazy initialization occurs, the default constructor of the target type is used.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of this constructor. It also illustrates the use of the <xref href=\"System.Lazy`1.#ctor(System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <strong>true</strong> for <em>isThreadSafe</em>) and the <xref href=\"System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>). To switch to a different constructor, just change which constructors are commented out. </p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily by one of several threads. The two key lines of code in this example are the creation of the initializer and the actual initialization. At the beginning of the <code>Main</code> method, the example creates the thread-safe lazy initializer for <code>LargeObject</code>: </p>System.Lazy`1.ctor#NewLazy<p>The example creates and starts three threads that block on a <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref> object, so that the example can release the threads all at once. The <code>ThreadProc</code> method that's used by all three threads calls the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property to get the <code>LargeObject</code> instance:</p>System.Lazy`1.ctor#ValueProp<p>The <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class provides locking, so that only one thread is allowed to create the <code>LargeObject</code> instance. The example demonstrates that the other threads all get the same instance. </p><p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1.ctor#All"
  syntax:
    content: public Lazy()
    content.vb: Public Sub New
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Lazy(Of T).Lazy()
  nameWithType: Lazy<T>.Lazy()
  nameWithType.vb: Lazy(Of T).Lazy()
- uid: System.Lazy`1.#ctor(System.Boolean)
  commentId: M:System.Lazy`1.#ctor(System.Boolean)
  id: '#ctor(System.Boolean)'
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Lazy(Boolean)
  fullName: System.Lazy<T>.Lazy(System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 149
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class. When lazy initialization occurs, the default constructor of the target type and the specified initialization mode are used.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of this constructor to create a lazy initializer that is not thread safe, for scenarios where all access to the lazily initialized object occurs on the same thread. It also demonstrates the use of the <xref href=\"System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.None\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>. To switch to a different constructor, just change which constructor is commented out.</p>\n<p>For code that demonstrates how to use this constructor in multithreaded scenarios (specifying <strong>true</strong> for <em>isThreadSafe</em>), see the example for the <xref href=\"System.Lazy`1.#ctor\" data-throw-if-not-resolved=\"false\"></xref> constructor. </p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily. In the <code>Main</code> method, the example creates a <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance and then pauses. When you press the Enter key, the example accesses the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance, which causes initialization to occur. The constructor of the <code>LargeObject</code> class displays a console message. </p>\n<p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1.ctorBool#All"
  syntax:
    content: public Lazy(bool isThreadSafe)
    content.vb: Public Sub New(isThreadSafe As Boolean)
    parameters:
    - id: isThreadSafe
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to make this instance usable concurrently by multiple threads; <strong>false</strong> to make the instance usable by only one thread at a time. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Lazy(Of T).Lazy(System.Boolean)
  nameWithType: Lazy<T>.Lazy(Boolean)
  nameWithType.vb: Lazy(Of T).Lazy(Boolean)
- uid: System.Lazy`1.#ctor(System.Func{`0})
  commentId: M:System.Lazy`1.#ctor(System.Func{`0})
  id: '#ctor(System.Func{`0})'
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Lazy(Func<T>)
  fullName: System.Lazy<T>.Lazy(System.Func<T>)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 138
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class. When lazy initialization occurs, the specified initialization function is used.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of this constructor to provide lazy initialization with exception caching. It also demonstrates the use of the <xref href=\"System.Lazy`1.#ctor(System.Func{`0},System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <strong>true</strong> for <em>isThreadSafe</em>) and the <xref href=\"System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)\" data-throw-if-not-resolved=\"false\"></xref> constructor (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>). To switch to a different constructor, just change which constructors are commented out. </p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily by one of several threads. The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor of the <code>LargeObject</code> class, which demonstrates exception caching. At the beginning of the <code>Main</code> method, the example creates the thread-safe lazy initializer for <code>LargeObject</code>: </p>System.Lazy`1.ctorFunc#NewLazy<p>The example creates and starts three threads. The <code>ThreadProc</code> method that's used by all three threads calls the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property to get the <code>LargeObject</code> instance:</p>System.Lazy`1.ctorFunc#ValueProp<p>In the constructor of the <code>LargeObject</code> class, the third key section of code throws an exception the first time a <code>LargeObject</code> instance is created, but thereafter allows instance creation to occur: </p>System.Lazy`1.ctorFunc#LargeCtor<p>When the example is run, the first thread that tries to create an instance of <code>LargeObject</code> fails, and the exception is caught. You might expect that the next thread would successfully create an instance, but the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> object has cached the exception. Because of this, all three threads throw the exception. </p><p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1.ctorFunc#All"
  syntax:
    content: public Lazy(Func<T> valueFactory)
    content.vb: Public Sub New(valueFactory As Func(Of T))
    parameters:
    - id: valueFactory
      type: System.Func{{T}}
      description: "\n<p>The delegate that is invoked to produce the lazily initialized value when it is needed.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>valueFactory</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Lazy(Of T).Lazy(System.Func(Of T))
  name.vb: Lazy(Func(Of T))
  nameWithType: Lazy<T>.Lazy(Func<T>)
  nameWithType.vb: Lazy(Of T).Lazy(Func(Of T))
- uid: System.Lazy`1.#ctor(System.Func{`0},System.Boolean)
  commentId: M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)
  id: '#ctor(System.Func{`0},System.Boolean)'
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Lazy(Func<T>, Boolean)
  fullName: System.Lazy<T>.Lazy(System.Func<T>, System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 177
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class. When lazy initialization occurs, the specified initialization function and initialization mode are used.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of this constructor to provide lazy initialization with exception caching, in a scenario with a single thread. It also demonstrates the use of the  <xref href=\"System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)\" data-throw-if-not-resolved=\"false\"></xref>constructor (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.None\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>). To switch to that constructor, just change which constructor is commented out. </p>\n<p>For code that demonstrates how to use this constructor in multithreaded scenarios (specifying <strong>true</strong> for <em>isThreadSafe</em>), see the example for the <xref href=\"System.Lazy`1.#ctor(System.Func{`0})\" data-throw-if-not-resolved=\"false\"></xref> constructor. </p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily by one of several threads. The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor of the <code>LargeObject</code> class, which demonstrates exception caching. At the beginning of the <code>Main</code> method, the example creates the thread-safe lazy initializer for <code>LargeObject</code>: </p>System.Lazy`1.ctorFuncBool#NewLazy<p>In the call to the constructor, the <em>isThreadSafe</em> parameter is <strong>false</strong>, so the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> is not thread safe. Because it's not thread safe, the example calls the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property three times on the same thread:</p>System.Lazy`1.ctorFuncBool#ValueProp<p>In the constructor of the <code>LargeObject</code> class, the third key section of code throws an exception the first time a <code>LargeObject</code> instance is created, but thereafter allows instance creation to occur: </p>System.Lazy`1.ctorFuncBool#LargeCtor<p>When the example is run, the first attempt to create an instance of <code>LargeObject</code> fails, and the exception is caught. You might expect that the next attempt would succeed, but the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> object has cached the exception. Because of this, all three attempts throw the exception. </p><p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1.ctorFuncBool#All"
  syntax:
    content: public Lazy(Func<T> valueFactory, bool isThreadSafe)
    content.vb: Public Sub New(valueFactory As Func(Of T), isThreadSafe As Boolean)
    parameters:
    - id: valueFactory
      type: System.Func{{T}}
      description: "\n<p>The delegate that is invoked to produce the lazily initialized value when it is needed.</p>\n"
    - id: isThreadSafe
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> to make this instance usable concurrently by multiple threads; <strong>false</strong> to make this instance usable by only one thread at a time.</p>\n"
  exceptions:
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>valueFactory</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Lazy(Of T).Lazy(System.Func(Of T), System.Boolean)
  name.vb: Lazy(Func(Of T), Boolean)
  nameWithType: Lazy<T>.Lazy(Func<T>, Boolean)
  nameWithType.vb: Lazy(Of T).Lazy(Func(Of T), Boolean)
- uid: System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)
  commentId: M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)
  id: '#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)'
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Lazy(Func<T>, LazyThreadSafetyMode)
  fullName: System.Lazy<T>.Lazy(System.Func<T>, System.Threading.LazyThreadSafetyMode)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 193
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class that uses the specified initialization function and thread-safety mode.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of this constructor to create a lazy initializer that enables multiple threads to race to create an object lazily. Multiple threads might succeed in creating instances, but all threads use the instance that was created first. In addition, the example demonstrates that exceptions are never cached when you specify <xref href=\"System.Threading.LazyThreadSafetyMode.PublicationOnly\" data-throw-if-not-resolved=\"false\"></xref>, even if initialization is performed by a function instead of by the default constructor of the lazily created type. </p>\n<p>For an example that demonstrates how to use this constructor in single-threaded scenarios (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.None\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>), see the <xref href=\"System.Lazy`1.#ctor(System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor. For an example that demonstrates how to use this constructor to provide locking instead of race conditions in multithreaded scenarios (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>), see the <xref href=\"System.Lazy`1.#ctor\" data-throw-if-not-resolved=\"false\"></xref> constructor.</p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily by any of several threads. The four key sections of code illustrate the creation of the initializer, the actual initialization, the initialization function, and the constructor and finalizer of the <code>LargeObject</code> class. At the beginning of the <code>Main</code> method, the example creates the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> object that performs lazy initialization of the <code>LargeObject</code>: </p>System.Lazy`1.ctorFuncLTSM#NewLazy<p>The lazy initializer uses a function to perform the initialization. In this case, a function is required because there is no default constructor for the <code>LargeObject</code> class. </p><p>The example creates and starts three threads that block on a <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref> object, so that the example can release the threads all at once. In the <code>ThreadProc</code> method that's used by all three threads, calling the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property creates the <code>LargeObject</code> instance:</p>System.Lazy`1.ctorFuncLTSM#ValueProp<p>In the third key section of code, the lazy initialization function is called to create the <code>LargeObject</code> instance. The function throws an exception the first time it's called: </p>System.Lazy`1.ctorFuncLTSM#FactoryFunc<p>With any other <xref href=\"System.Threading.LazyThreadSafetyMode\" data-throw-if-not-resolved=\"false\"></xref> setting, an unhandled exception in the initialization function would be cached. However, <xref href=\"System.Threading.LazyThreadSafetyMode.PublicationOnly\" data-throw-if-not-resolved=\"false\"></xref> suppresses exception caching. The output from the example demonstrates that a subsequent attempt to initialize the object succeeds. </p><p>The exception message usually appears after messages indicating that other threads have successfully initialized the object. This is because of the delay introduced by throwing and catching the exception. </p><p>Because the constructor for the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance specified <xref href=\"System.Threading.LazyThreadSafetyMode.PublicationOnly\" data-throw-if-not-resolved=\"false\"></xref>, all three threads are allowed to create <code>LargeObject</code> instances. The example demonstrates this by displaying console messages in the constructor and in the finalizer of the <code>LargeObject</code> class: </p>System.Lazy`1.ctorFuncLTSM#CtorFinalizer<p>The <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> object ensures that only one instance is used by all threads (except the thread where the initialization function throws an exception). The output from the example shows this. </p><p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1.ctorFuncLTSM#All"
  syntax:
    content: public Lazy(Func<T> valueFactory, LazyThreadSafetyMode mode)
    content.vb: Public Sub New(valueFactory As Func(Of T), mode As LazyThreadSafetyMode)
    parameters:
    - id: valueFactory
      type: System.Func{{T}}
      description: "\n<p>The delegate that is invoked to produce the lazily initialized value when it is needed.</p>\n"
    - id: mode
      type: System.Threading.LazyThreadSafetyMode
      description: "\n<p>One of the enumeration values that specifies the thread safety mode. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>mode</em> contains an invalid value. </p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>valueFactory</em> is <strong>null</strong>. </p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Lazy(Of T).Lazy(System.Func(Of T), System.Threading.LazyThreadSafetyMode)
  name.vb: Lazy(Func(Of T), LazyThreadSafetyMode)
  nameWithType: Lazy<T>.Lazy(Func<T>, LazyThreadSafetyMode)
  nameWithType.vb: Lazy(Of T).Lazy(Func(Of T), LazyThreadSafetyMode)
- uid: System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)
  commentId: M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)
  id: '#ctor(System.Threading.LazyThreadSafetyMode)'
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Lazy(LazyThreadSafetyMode)
  fullName: System.Lazy<T>.Lazy(System.Threading.LazyThreadSafetyMode)
  type: Constructor
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: .ctor
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 160
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> class that uses the default constructor of <em>T</em> and the specified thread-safety mode.</p>\n"
  example:
  - "\n<p>The following example demonstrates the use of this constructor to create a lazy initializer that enables multiple threads to race to create an object lazily. Multiple threads might succeed in creating instances, but all threads use the instance that was created first. </p>\n<p>For an example that demonstrates how to use this constructor in single-threaded scenarios (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.None\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>), see the <xref href=\"System.Lazy`1.#ctor(System.Boolean)\" data-throw-if-not-resolved=\"false\"></xref> constructor. For an example that demonstrates how to use this constructor to provide locking instead of race conditions in multithreaded scenarios (specifying <xref href=\"System.Threading.LazyThreadSafetyMode.ExecutionAndPublication\" data-throw-if-not-resolved=\"false\"></xref> for <em>mode</em>), see the <xref href=\"System.Lazy`1.#ctor\" data-throw-if-not-resolved=\"false\"></xref> constructor.</p>\n<p>The example defines a <code>LargeObject</code> class that will be initialized lazily by any of several threads. The three key sections of code illustrate the creation of the initializer, the actual initialization, and the constructor and finalizer of the <code>LargeObject</code> class. At the beginning of the <code>Main</code> method, the example creates the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> object that performs lazy initialization of the <code>LargeObject</code>: </p>System.Lazy`1.ctorLTSM#NewLazy<p>The example creates and starts three threads that block on a <xref href=\"System.Threading.ManualResetEvent\" data-throw-if-not-resolved=\"false\"></xref> object, so that the example can release the threads all at once. In the <code>ThreadProc</code> method that's used by all three threads, calling the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property creates the <code>LargeObject</code> instance:</p>System.Lazy`1.ctorLTSM#ValueProp<p>Because the constructor for the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance specified <xref href=\"System.Threading.LazyThreadSafetyMode.PublicationOnly\" data-throw-if-not-resolved=\"false\"></xref>, all three threads are allowed to create <code>LargeObject</code> instances. The example demonstrates this by displaying console messages in the constructor and in the finalizer of the <code>LargeObject</code> class: </p>System.Lazy`1.ctorLTSM#CtorFinalizer<p>However, the <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> object ensures that only one instance is used by all threads. The output from the example shows that all three threads use the same instance, and also shows that the other two instances can be reclaimed by garbage collection.</p><p>For simplicity, this example uses a global instance of <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref>, and all the methods are <strong>static</strong> (<strong>Shared</strong> in Visual Basic). These are not requirements for the use of lazy initialization. </p>System.Lazy`1.ctorLTSM#All"
  syntax:
    content: public Lazy(LazyThreadSafetyMode mode)
    content.vb: Public Sub New(mode As LazyThreadSafetyMode)
    parameters:
    - id: mode
      type: System.Threading.LazyThreadSafetyMode
      description: "\n<p>One of the enumeration values that specifies the thread safety mode. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>mode</em> contains an invalid value. </p>\n"
  seealso:
  - type: System.Threading.LazyThreadSafetyMode
    commentId: T:System.Threading.LazyThreadSafetyMode
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Lazy(Of T).Lazy(System.Threading.LazyThreadSafetyMode)
  nameWithType: Lazy<T>.Lazy(LazyThreadSafetyMode)
  nameWithType.vb: Lazy(Of T).Lazy(LazyThreadSafetyMode)
- uid: System.Lazy`1.IsValueCreated
  commentId: P:System.Lazy`1.IsValueCreated
  id: IsValueCreated
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: IsValueCreated
  fullName: System.Lazy<T>.IsValueCreated
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: IsValueCreated
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 280
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets a value that indicates whether a value has been created for this <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n"
  example:
  - 
  syntax:
    content: public bool IsValueCreated { get; }
    content.vb: Public ReadOnly Property IsValueCreated As Boolean
    parameters: []
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if a value has been created for this <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance; otherwise, <strong>false</strong>.</p>\n"
  seealso:
  - type: System.Threading.LazyThreadSafetyMode
    commentId: T:System.Threading.LazyThreadSafetyMode
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
  fullName.vb: System.Lazy(Of T).IsValueCreated
  nameWithType: Lazy<T>.IsValueCreated
  nameWithType.vb: Lazy(Of T).IsValueCreated
- uid: System.Lazy`1.Value
  commentId: P:System.Lazy`1.Value
  id: Value
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: Value
  fullName: System.Lazy<T>.Value
  type: Property
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: Value
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 309
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Gets the lazily initialized value of the current <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n"
  example:
  - 
  syntax:
    content: >-
      [DebuggerBrowsable(DebuggerBrowsableState.Never)]

      public T Value { get; }
    content.vb: >-
      <DebuggerBrowsable(DebuggerBrowsableState.Never)>

      Public ReadOnly Property Value As T
    parameters: []
    return:
      type: '{T}'
      description: "\n<p>The lazily initialized value of the current <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance.</p>\n"
  exceptions:
  - type: System.MemberAccessException
    commentId: T:System.MemberAccessException
    description: "\n<p>The <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance is initialized to use the default constructor of the type that is being lazily initialized, and permissions to access the constructor are missing. </p>\n"
  - type: System.MissingMemberException
    commentId: T:System.MissingMemberException
    description: "\n<p>The <xref href=\"System.Lazy`1\" data-throw-if-not-resolved=\"false\"></xref> instance is initialized to use the default constructor of the type that is being lazily initialized, and that type does not have a public, parameterless constructor. </p>\n"
  - type: System.InvalidOperationException
    commentId: T:System.InvalidOperationException
    description: "\n<p>The initialization function tries to access <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> on this instance. </p>\n"
  modifiers.csharp:
  - public
  - get
  modifiers.vb:
  - Public
  - ReadOnly
  fullName.vb: System.Lazy(Of T).Value
  nameWithType: Lazy<T>.Value
  nameWithType.vb: Lazy(Of T).Value
- uid: System.Lazy`1.ToString
  commentId: M:System.Lazy`1.ToString
  id: ToString
  parent: System.Lazy`1
  langs:
  - csharp
  - vb
  name: ToString()
  fullName: System.Lazy<T>.ToString()
  type: Method
  source:
    remote:
      path: src/mscorlib/src/System/Lazy.cs
      branch: master
      repo: https://github.com/dotnet/coreclr.git
    id: ToString
    path: src/mscorlib/src/System/Lazy.cs
    startLine: 232
  assemblies:
  - System.Runtime
  namespace: System
  summary: "\n<p>Creates and returns a string representation of the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property for this instance.</p>\n"
  example:
  - 
  syntax:
    content: public override string ToString()
    content.vb: Public Overrides Function ToString As String
    return:
      type: System.String
      description: "\n<p>The result of calling the <xref href=\"System.Object.ToString\" data-throw-if-not-resolved=\"false\"></xref> method on the <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property for this instance, if the value has been created (that is, if the <xref href=\"System.Lazy`1.IsValueCreated\" data-throw-if-not-resolved=\"false\"></xref> property returns <strong>true</strong>). Otherwise, a string indicating that the value has not been created. </p>\n"
  overridden: System.Object.ToString
  exceptions:
  - type: System.NullReferenceException
    commentId: T:System.NullReferenceException
    description: "\n<p>The <xref href=\"System.Lazy`1.Value\" data-throw-if-not-resolved=\"false\"></xref> property is <strong>null</strong>.</p>\n"
  modifiers.csharp:
  - public
  - override
  modifiers.vb:
  - Public
  - Overrides
  fullName.vb: System.Lazy(Of T).ToString()
  nameWithType: Lazy<T>.ToString()
  nameWithType.vb: Lazy(Of T).ToString()
references:
- uid: System
  isExternal: false
  name: System
  fullName: System
  nameWithType: System
  commentId: N:System
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
  nameWithType: Object
  commentId: T:System.Object
- uid: System.Object.Equals(System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object)
  fullName: System.Object.Equals(System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  nameWithType: Object.Equals(Object)
  commentId: M:System.Object.Equals(System.Object)
- uid: System.Object.Equals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: Equals(Object, Object)
  fullName: System.Object.Equals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.Equals(System.Object,System.Object)
    name: Equals
    fullName: System.Object.Equals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  nameWithType: Object.Equals(Object, Object)
  commentId: M:System.Object.Equals(System.Object,System.Object)
- uid: System.Object.ReferenceEquals(System.Object,System.Object)
  parent: System.Object
  isExternal: true
  name: ReferenceEquals(Object, Object)
  fullName: System.Object.ReferenceEquals(System.Object, System.Object)
  spec.csharp:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ReferenceEquals(System.Object,System.Object)
    name: ReferenceEquals
    fullName: System.Object.ReferenceEquals
    isExternal: true
  - name: (
    fullName: (
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: ', '
    fullName: ', '
  - uid: System.Object
    name: Object
    fullName: System.Object
    isExternal: true
  - name: )
    fullName: )
  nameWithType: Object.ReferenceEquals(Object, Object)
  commentId: M:System.Object.ReferenceEquals(System.Object,System.Object)
- uid: System.Object.GetHashCode
  parent: System.Object
  isExternal: true
  name: GetHashCode()
  fullName: System.Object.GetHashCode()
  spec.csharp:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetHashCode
    name: GetHashCode
    fullName: System.Object.GetHashCode
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.GetHashCode()
  commentId: M:System.Object.GetHashCode
- uid: System.Object.GetType
  parent: System.Object
  isExternal: true
  name: GetType()
  fullName: System.Object.GetType()
  spec.csharp:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.GetType
    name: GetType
    fullName: System.Object.GetType
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.GetType()
  commentId: M:System.Object.GetType
- uid: System.Object.MemberwiseClone
  parent: System.Object
  isExternal: true
  name: MemberwiseClone()
  fullName: System.Object.MemberwiseClone()
  spec.csharp:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.MemberwiseClone
    name: MemberwiseClone
    fullName: System.Object.MemberwiseClone
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.MemberwiseClone()
  commentId: M:System.Object.MemberwiseClone
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
  nameWithType: Boolean
  commentId: T:System.Boolean
- uid: System.Func{{T}}
  parent: System
  definition: System.Func`1
  name: Func<T>
  fullName: System.Func<T>
  fullname.vb: System.Func(Of T)
  name.vb: Func(Of T)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    fullName: System.Func
  - name: <
    fullName: <
  - name: T
    fullName: T
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    fullName: System.Func
  - name: '(Of '
    fullName: '(Of '
  - name: T
    fullName: T
  - name: )
    fullName: )
  nameWithType: Func<T>
  nameWithType.vb: Func(Of T)
  commentId: T:System.Func{``0}
- uid: System.Func`1
  isExternal: false
  name: Func<TResult>
  fullName: System.Func<TResult>
  fullname.vb: System.Func(Of TResult)
  name.vb: Func(Of TResult)
  spec.csharp:
  - uid: System.Func`1
    name: Func
    fullName: System.Func
  - name: <
    fullName: <
  - name: TResult
    fullName: TResult
  - name: '>'
    fullName: '>'
  spec.vb:
  - uid: System.Func`1
    name: Func
    fullName: System.Func
  - name: '(Of '
    fullName: '(Of '
  - name: TResult
    fullName: TResult
  - name: )
    fullName: )
  nameWithType: Func<TResult>
  nameWithType.vb: Func(Of TResult)
  commentId: T:System.Func`1
- uid: System.Threading.LazyThreadSafetyMode
  parent: System.Threading
  isExternal: false
  name: LazyThreadSafetyMode
  fullName: System.Threading.LazyThreadSafetyMode
  nameWithType: LazyThreadSafetyMode
  commentId: T:System.Threading.LazyThreadSafetyMode
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
  nameWithType: System.Threading
  commentId: N:System.Threading
- uid: '{T}'
  definition: T
  name: T
  fullName: T
  nameWithType: T
  commentId: '!:T'
- uid: T
  isExternal: false
  name: T
  fullName: T
  nameWithType: T
- uid: System.Object.ToString
  parent: System.Object
  isExternal: true
  name: ToString()
  fullName: System.Object.ToString()
  spec.csharp:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  spec.vb:
  - uid: System.Object.ToString
    name: ToString
    fullName: System.Object.ToString
    isExternal: true
  - name: (
    fullName: (
  - name: )
    fullName: )
  nameWithType: Object.ToString()
  commentId: M:System.Object.ToString
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
  nameWithType: String
  commentId: T:System.String
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
  nameWithType: ArgumentNullException
  commentId: T:System.ArgumentNullException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
  nameWithType: ArgumentOutOfRangeException
  commentId: T:System.ArgumentOutOfRangeException
- uid: System.MemberAccessException
  parent: System
  isExternal: false
  name: MemberAccessException
  fullName: System.MemberAccessException
  nameWithType: MemberAccessException
  commentId: T:System.MemberAccessException
- uid: System.MissingMemberException
  parent: System
  isExternal: false
  name: MissingMemberException
  fullName: System.MissingMemberException
  nameWithType: MissingMemberException
  commentId: T:System.MissingMemberException
- uid: System.InvalidOperationException
  parent: System
  isExternal: false
  name: InvalidOperationException
  fullName: System.InvalidOperationException
  nameWithType: InvalidOperationException
  commentId: T:System.InvalidOperationException
- uid: System.NullReferenceException
  isExternal: false
  name: NullReferenceException
  fullName: System.NullReferenceException
  nameWithType: NullReferenceException
  commentId: T:System.NullReferenceException
