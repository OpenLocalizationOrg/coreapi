items:
- uid: System.Threading.Semaphore
  commentId: T:System.Threading.Semaphore
  id: Semaphore
  parent: System.Threading
  children:
  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32)
  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)
  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)
  - System.Threading.Semaphore.OpenExisting(System.String)
  - System.Threading.Semaphore.Release
  - System.Threading.Semaphore.Release(System.Int32)
  - System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)
  langs:
  - csharp
  - vb
  name: Semaphore
  fullName: System.Threading.Semaphore
  type: Class
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Semaphore
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 244
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Limits the number of threads that can access a resource or pool of resources concurrently. </p>\n"
  remarks: "\n<p>Use the <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class to control access to a pool of resources. Threads enter the semaphore by calling the <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> method, which is inherited from the <xref href=\"System.Threading.WaitHandle\" data-throw-if-not-resolved=\"false\"></xref> class, and release the semaphore by calling the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method.</p>\n<p>The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.</p>\n<p>There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.</p>\n<p>A thread can enter the semaphore multiple times, by calling the <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> method repeatedly. To release some or all of these entries, the thread can call the parameterless <xref href=\"System.Threading.Semaphore.Release\" data-throw-if-not-resolved=\"false\"></xref> method overload multiple times, or it can call the <xref href=\"System.Threading.Semaphore.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload that specifies the number of entries to be released.</p>\n<p>The <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class does not enforce thread identity on calls to <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> or <see cref=\"Overload:System.Threading.Semaphore.Release\"></see>. It is the programmer's responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <see cref=\"Overload:System.Threading.Semaphore.Release\"></see>, a <xref href=\"System.Threading.SemaphoreFullException\" data-throw-if-not-resolved=\"false\"></xref> is thrown.</p>\n<p>Semaphores are of two types: local semaphores and named system semaphores. If you create a <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the same named system semaphore, and you can use the <see cref=\"Overload:System.Threading.Semaphore.OpenExisting\"></see> method to open an existing named system semaphore.</p>\n<p>A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object. Each <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object is a separate local semaphore.</p>\n"
  example:
  - "\n<p>The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref href=\"System.Threading.Semaphore.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <see cref=\"Overload:System.Threading.Thread.Sleep\"></see> method to wait for one second, to simulate work, and then calls the <xref href=\"System.Threading.Semaphore.Release\" data-throw-if-not-resolved=\"false\"></xref> method overload to release the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.</p>System.Threading.Semaphore2#1"
  syntax:
    content: 'public sealed class Semaphore : WaitHandle'
    content.vb: >-
      Public NotInheritable Class Semaphore
          Inherits WaitHandle
  inheritance:
  - System.Object
  modifiers.csharp:
  - public
  - sealed
  - class
  modifiers.vb:
  - Public
  - NotInheritable
  - Class
- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32)
  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)
  id: '#ctor(System.Int32,System.Int32)'
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: Semaphore(Int32, Int32)
  fullName: System.Threading.Semaphore.Semaphore(System.Int32, System.Int32)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 246
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries. </p>\n"
  remarks: "\n<p>This constructor initializes an unnamed semaphore. All threads that use an instance of such a semaphore must have references to the instance.</p>\n<p>If <em>initialCount</em> is less than <em>maximumCount</em>, the effect is the same as if the current thread had called <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> (<em>maximumCount</em> minus <em>initialCount</em>) times. If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <em>maximumCount</em> and <em>initialCount</em>.</p>\n"
  example:
  - "\n<p>The following example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref href=\"System.Threading.Semaphore.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <see cref=\"Overload:System.Threading.Thread.Sleep\"></see> method to wait for one second, to simulate work, and then calls the <xref href=\"System.Threading.Semaphore.Release\" data-throw-if-not-resolved=\"false\"></xref> method overload to release the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.</p>System.Threading.Semaphore2#1"
  syntax:
    content: public Semaphore(int initialCount, int maximumCount)
    content.vb: Public Sub New(initialCount As Integer, maximumCount As Integer)
    parameters:
    - id: initialCount
      type: System.Int32
      description: "\n<p>The initial number of requests for the semaphore that can be granted concurrently. </p>\n"
    - id: maximumCount
      type: System.Int32
      description: "\n<p>The maximum number of requests for the semaphore that can be granted concurrently. </p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>initialCount</em> is greater than <em>maximumCount</em>.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>maximumCount</em> is less than 1.</p>\n<p>-or-</p>\n<p>\n<em>initialCount</em> is less than 0.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)
  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)
  id: '#ctor(System.Int32,System.Int32,System.String)'
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: Semaphore(Int32, Int32, String)
  fullName: System.Threading.Semaphore.Semaphore(System.Int32, System.Int32, System.String)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 247
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object. </p>\n"
  remarks: "\n<p>This constructor initializes a <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object that represents a named system semaphore. You can create multiple <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the same named system semaphore.</p>\n<p>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <em>initialCount</em> and <em>maximumCount</em>. If the named system semaphore already exists, <em>initialCount</em> and <em>maximumCount</em> are not used, although invalid values still cause exceptions. If you need to determine whether or not a named system semaphore was created, use the <xref href=\"System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)\" data-throw-if-not-resolved=\"false\"></xref> constructor overload instead. </p>\n<p>When you use this constructor overload, the recommended practice is to specify the same number for <em>initialCount</em> and <em>maximumCount</em>. If <em>initialCount</em> is less than <em>maximumCount</em>, and a named system semaphore is created, the effect is the same as if the current thread had called <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> (<em>maximumCount</em> minus <em>initialCount</em>) times. However, with this constructor overload there is no way to determine whether a named system semaphore was created. </p>\n<p>If you specify <strong>null</strong> or an empty string for <em>name</em>, a local semaphore is created, as if you had called the <xref href=\"System.Threading.Semaphore.#ctor(System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> constructor overload.</p>\n<p>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</p>\n<p>If you want to find out whether a named system semaphore exists, use the <see cref=\"Overload:System.Threading.Semaphore.OpenExisting\"></see> method. The <see cref=\"Overload:System.Threading.Semaphore.OpenExisting\"></see> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the cross-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of five. The program makes three calls to the <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see>. Release one or more entries in the first copy of the program to unblock the second.</p>System.Threading.Semaphore.ctor named 3#1"
  syntax:
    content: public Semaphore(int initialCount, int maximumCount, string name)
    content.vb: Public Sub New(initialCount As Integer, maximumCount As Integer, name As String)
    parameters:
    - id: initialCount
      type: System.Int32
      description: "\n<p>The initial number of requests for the semaphore that can be granted concurrently. </p>\n"
    - id: maximumCount
      type: System.Int32
      description: "\n<p>The maximum number of requests for the semaphore that can be granted concurrently.</p>\n"
    - id: name
      type: System.String
      description: "\n<p>The name of a named system semaphore object.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>initialCount</em> is greater than <em>maximumCount</em>.</p>\n<p>-or-</p>\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>maximumCount</em> is less than 1.</p>\n<p>-or-</p>\n<p>\n<em>initialCount</em> is less than 0.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Threading.WaitHandleCannotBeOpenedException
    commentId: T:System.Threading.WaitHandleCannotBeOpenedException
    description: "\n<p>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)
  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)
  id: '#ctor(System.Int32,System.Int32,System.String,System.Boolean@)'
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: Semaphore(Int32, Int32, String, out Boolean)
  fullName: System.Threading.Semaphore.Semaphore(System.Int32, System.Int32, System.String, out System.Boolean)
  type: Constructor
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: .ctor
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 248
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Initializes a new instance of the <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</p>\n"
  remarks: "\n<p>This constructor initializes a <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object that represents a named system semaphore. You can create multiple <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> objects that represent the same named system semaphore.</p>\n<p>If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <em>initialCount</em> and <em>maximumCount</em>. If the named system semaphore already exists, <em>initialCount</em> and <em>maximumCount</em> are not used, although invalid values still cause exceptions. Use <em>createdNew</em> to determine whether the system semaphore was created. </p>\n<p>If <em>initialCount</em> is less than <em>maximumCount</em>, and <em>createdNew</em> is <strong>true</strong>, the effect is the same as if the current thread had called <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> (<em>maximumCount</em> minus <em>initialCount</em>) times.</p>\n<p>If you specify <strong>null</strong> or an empty string for <em>name</em>, a local semaphore is created, as if you had called the <xref href=\"System.Threading.Semaphore.#ctor(System.Int32,System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> constructor overload. In this case, <em>createdNew</em> is always <strong>true</strong>.</p>\n<p>Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the cross-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of two. That is, it reserves three entries for the thread that calls the constructor. If <em>createNew</em> is <strong>false</strong>, the program makes three calls to the <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see>. Release one or more entries in the first copy of the program to unblock the second.</p>System.Threading.Semaphore.ctor named 4#1"
  syntax:
    content: public Semaphore(int initialCount, int maximumCount, string name, out bool createdNew)
    content.vb: Public Sub New(initialCount As Integer, maximumCount As Integer, name As String, ByRef createdNew As Boolean)
    parameters:
    - id: initialCount
      type: System.Int32
      description: "\n<p>The initial number of requests for the semaphore that can be satisfied concurrently. </p>\n"
    - id: maximumCount
      type: System.Int32
      description: "\n<p>The maximum number of requests for the semaphore that can be satisfied concurrently.</p>\n"
    - id: name
      type: System.String
      description: "\n<p>The name of a named system semaphore object.</p>\n"
    - id: createdNew
      type: System.Boolean
      description: "\n<p>When this method returns, contains <strong>true</strong> if a local semaphore was created (that is, if <em>name</em> is <strong>null</strong> or an empty string) or if the specified named system semaphore was created; <strong>false</strong> if the specified named system semaphore already existed. This parameter is passed uninitialized.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>initialCount</em> is greater than <em>maximumCount</em>. </p>\n<p>-or-</p>\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>maximumCount</em> is less than 1.</p>\n<p>-or-</p>\n<p>\n<em>initialCount</em> is less than 0.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  - type: System.Threading.WaitHandleCannotBeOpenedException
    commentId: T:System.Threading.WaitHandleCannotBeOpenedException
    description: "\n<p>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
  fullName.vb: System.Threading.Semaphore.Semaphore(System.Int32, System.Int32, System.String, ByRef System.Boolean)
  name.vb: Semaphore(Int32, Int32, String, ByRef Boolean)
- uid: System.Threading.Semaphore.OpenExisting(System.String)
  commentId: M:System.Threading.Semaphore.OpenExisting(System.String)
  id: OpenExisting(System.String)
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: OpenExisting(String)
  fullName: System.Threading.Semaphore.OpenExisting(System.String)
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: OpenExisting
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 249
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Opens the specified named semaphore, if it already exists.</p>\n"
  remarks: "\n<p>The <see cref=\"Overload:System.Threading.Semaphore.OpenExisting\"></see> method tries to open the specified named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref href=\"System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> constructors that has a <em>name</em> parameter.</p>\n<p>Multiple calls to this method that use the same value for <em>name</em> do not necessarily return the same <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object, even though the objects that are returned represent the same named system semaphore. </p>\n<p>This method overload is equivalent to calling the <xref href=\"System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying <xref href=\"System.Security.AccessControl.SemaphoreRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights, combined by using the bitwise OR operation.</p>\n<p>Specifying the <xref href=\"System.Security.AccessControl.SemaphoreRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to enter the semaphore, and specifying the <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to call the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method.</p>\n"
  example:
  - "\n<p>The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <xref href=\"System.Threading.Semaphore.OpenExisting(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method overload to test for the existence of a named semaphore.</p>\n<p>If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore. </p>\n<p>If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref href=\"System.Threading.Semaphore.OpenExisting(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method overload. The exception is caught, and the example uses the <xref href=\"System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\" data-throw-if-not-resolved=\"false\"></xref> method overload to open the semaphore with the rights needed to read and change the permissions. </p>\n<p>After the permissions are changed, the semaphore is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.</p>System.Threading.Semaphore.ctor named 5a#1"
  syntax:
    content: public static Semaphore OpenExisting(string name)
    content.vb: Public Shared Function OpenExisting(name As String) As Semaphore
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the system semaphore to open.</p>\n"
    return:
      type: System.Threading.Semaphore
      description: "\n<p>An object that represents the named system semaphore.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is an empty string.</p>\n<p>-or-</p>\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>.</p>\n"
  - type: System.Threading.WaitHandleCannotBeOpenedException
    commentId: T:System.Threading.WaitHandleCannotBeOpenedException
    description: "\n<p>The named semaphore does not exist.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named semaphore exists, but the user does not have the security access required to use it. </p>\n"
  see:
  - type: System.Security.Permissions.SecurityPermission
    commentId: T:System.Security.Permissions.SecurityPermission
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
- uid: System.Threading.Semaphore.Release
  commentId: M:System.Threading.Semaphore.Release
  id: Release
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: Release()
  fullName: System.Threading.Semaphore.Release()
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Release
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 250
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Exits the semaphore and returns the previous count.</p>\n"
  remarks: "\n<p>Threads typically use the <see cref=\"Overload:System.Threading.WaitHandle.WaitOne\"></see> method to enter the semaphore, and they typically use this method overload to exit.</p>\n<p>If a <xref href=\"System.Threading.SemaphoreFullException\" data-throw-if-not-resolved=\"false\"></xref> is thrown by the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</p>\n<p>If the current <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object represents a named system semaphore, the user must have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights and the semaphore must have been opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights.</p>\n"
  example:
  - "\n<p>The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref href=\"System.Threading.Semaphore.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <see cref=\"Overload:System.Threading.Thread.Sleep\"></see> method to wait for one second, to simulate work, and then calls the <xref href=\"System.Threading.Semaphore.Release\" data-throw-if-not-resolved=\"false\"></xref> method overload to release the semaphore. </p>\n<p>Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.</p>System.Threading.Semaphore2#1"
  syntax:
    content: public int Release()
    content.vb: Public Function Release As Integer
    return:
      type: System.Int32
      description: "\n<p>The count on the semaphore before the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method was called. </p>\n"
  exceptions:
  - type: System.Threading.SemaphoreFullException
    commentId: T:System.Threading.SemaphoreFullException
    description: "\n<p>The semaphore count is already at the maximum value.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred with a named semaphore.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The current semaphore represents a named system semaphore, but the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n<p>-or-</p>\n<p>The current semaphore represents a named system semaphore, but it was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref>.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Semaphore.Release(System.Int32)
  commentId: M:System.Threading.Semaphore.Release(System.Int32)
  id: Release(System.Int32)
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: Release(Int32)
  fullName: System.Threading.Semaphore.Release(System.Int32)
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: Release
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 251
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Exits the semaphore a specified number of times and returns the previous count.</p>\n"
  remarks: "\n<p>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.</p>\n<p>If a <xref href=\"System.Threading.SemaphoreFullException\" data-throw-if-not-resolved=\"false\"></xref> is thrown by the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.</p>\n<p>If the current <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object represents a named system semaphore, the user must have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights and the semaphore must have been opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights.</p>\n"
  example:
  - "\n<p>The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref href=\"System.Threading.Semaphore.Release(System.Int32)\" data-throw-if-not-resolved=\"false\"></xref> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <see cref=\"Overload:System.Threading.Thread.Sleep\"></see> method to wait for one second, to simulate work, and then calls the <xref href=\"System.Threading.Semaphore.Release\" data-throw-if-not-resolved=\"false\"></xref> method overload to release the semaphore. </p>\n<p>Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.</p>System.Threading.Semaphore2#1"
  syntax:
    content: public int Release(int releaseCount)
    content.vb: Public Function Release(releaseCount As Integer) As Integer
    parameters:
    - id: releaseCount
      type: System.Int32
      description: "\n<p>The number of times to exit the semaphore.</p>\n"
    return:
      type: System.Int32
      description: "\n<p>The count on the semaphore before the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method was called. </p>\n"
  exceptions:
  - type: System.ArgumentOutOfRangeException
    commentId: T:System.ArgumentOutOfRangeException
    description: "\n<p>\n<em>releaseCount</em> is less than 1.</p>\n"
  - type: System.Threading.SemaphoreFullException
    commentId: T:System.Threading.SemaphoreFullException
    description: "\n<p>The semaphore count is already at the maximum value.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred with a named semaphore.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The current semaphore represents a named system semaphore, but the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights.</p>\n<p>-or-</p>\n<p>The current semaphore represents a named system semaphore, but it was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights.</p>\n"
  modifiers.csharp:
  - public
  modifiers.vb:
  - Public
- uid: System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)
  commentId: M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)
  id: TryOpenExisting(System.String,System.Threading.Semaphore@)
  parent: System.Threading.Semaphore
  langs:
  - csharp
  - vb
  name: TryOpenExisting(String, out Semaphore)
  fullName: System.Threading.Semaphore.TryOpenExisting(System.String, out System.Threading.Semaphore)
  type: Method
  source:
    remote:
      path: src/System.Threading/ref/System.Threading.cs
      branch: master
      repo: https://github.com/dotnet/corefx.git
    id: TryOpenExisting
    path: src/System.Threading/ref/System.Threading.cs
    startLine: 252
  assemblies:
  - System.Threading
  namespace: System.Threading
  summary: "\n<p>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n"
  remarks: "\n<p>If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref href=\"System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)\" data-throw-if-not-resolved=\"false\"></xref> constructors that has a <em>name</em> parameter.</p>\n<p>If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref href=\"System.Threading.Semaphore.OpenExisting(System.String)\" data-throw-if-not-resolved=\"false\"></xref> method overload, which throws an exception if the semaphore does not exist.</p>\n<p>This method overload is equivalent to calling the <xref href=\"System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)\" data-throw-if-not-resolved=\"false\"></xref> method overload and specifying <xref href=\"System.Security.AccessControl.SemaphoreRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> and <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> rights, combined by using the bitwise OR operation. Specifying the <xref href=\"System.Security.AccessControl.SemaphoreRights.Synchronize\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to enter the semaphore, and specifying the   <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\" data-throw-if-not-resolved=\"false\"></xref> flag allows a thread to call the <see cref=\"Overload:System.Threading.Semaphore.Release\"></see> method. </p>\n"
  syntax:
    content: public static bool TryOpenExisting(string name, out Semaphore result)
    content.vb: Public Shared Function TryOpenExisting(name As String, ByRef result As Semaphore) As Boolean
    parameters:
    - id: name
      type: System.String
      description: "\n<p>The name of the system semaphore to open.</p>\n"
    - id: result
      type: System.Threading.Semaphore
      description: "\n<p>When this method returns, contains a <xref href=\"System.Threading.Semaphore\" data-throw-if-not-resolved=\"false\"></xref> object that represents the named semaphore if the call succeeded, or <strong>null</strong> if the call failed. This parameter is treated as uninitialized.</p>\n"
    return:
      type: System.Boolean
      description: "\n<p>\n<strong>true</strong> if the named semaphore was opened successfully; otherwise, <strong>false</strong>.</p>\n"
  exceptions:
  - type: System.ArgumentException
    commentId: T:System.ArgumentException
    description: "\n<p>\n<em>name</em> is an empty string.</p>\n<p>-or-</p>\n<p>\n<em>name</em> is longer than 260 characters.</p>\n"
  - type: System.ArgumentNullException
    commentId: T:System.ArgumentNullException
    description: "\n<p>\n<em>name</em> is <strong>null</strong>.</p>\n"
  - type: System.IO.IOException
    commentId: T:System.IO.IOException
    description: "\n<p>A Win32 error occurred.</p>\n"
  - type: System.UnauthorizedAccessException
    commentId: T:System.UnauthorizedAccessException
    description: "\n<p>The named semaphore exists, but the user does not have the security access required to use it. </p>\n"
  modifiers.csharp:
  - public
  - static
  modifiers.vb:
  - Public
  - Shared
  fullName.vb: System.Threading.Semaphore.TryOpenExisting(System.String, ByRef System.Threading.Semaphore)
  name.vb: TryOpenExisting(String, ByRef Semaphore)
references:
- uid: System.Threading
  isExternal: false
  name: System.Threading
  fullName: System.Threading
- uid: System.Object
  parent: System
  isExternal: false
  name: Object
  fullName: System.Object
- uid: System
  isExternal: false
  name: System
  fullName: System
- uid: System.Int32
  parent: System
  isExternal: false
  name: Int32
  fullName: System.Int32
- uid: System.String
  parent: System
  isExternal: false
  name: String
  fullName: System.String
- uid: System.Boolean
  parent: System
  isExternal: false
  name: Boolean
  fullName: System.Boolean
- uid: System.Threading.Semaphore
  parent: System.Threading
  isExternal: false
  name: Semaphore
  fullName: System.Threading.Semaphore
- uid: System.ArgumentException
  parent: System
  isExternal: false
  name: ArgumentException
  fullName: System.ArgumentException
- uid: System.ArgumentOutOfRangeException
  isExternal: false
  name: ArgumentOutOfRangeException
  fullName: System.ArgumentOutOfRangeException
- uid: System.IO.IOException
  parent: System.IO
  isExternal: false
  name: IOException
  fullName: System.IO.IOException
- uid: System.UnauthorizedAccessException
  isExternal: false
  name: UnauthorizedAccessException
  fullName: System.UnauthorizedAccessException
- uid: System.Threading.WaitHandleCannotBeOpenedException
  isExternal: false
  name: WaitHandleCannotBeOpenedException
  fullName: System.Threading.WaitHandleCannotBeOpenedException
- uid: System.ArgumentNullException
  isExternal: false
  name: ArgumentNullException
  fullName: System.ArgumentNullException
- uid: System.Threading.SemaphoreFullException
  isExternal: false
  name: SemaphoreFullException
  fullName: System.Threading.SemaphoreFullException
